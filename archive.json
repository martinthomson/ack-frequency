{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-09-14T00:55:51.144469+00:00",
  "repo": "quicwg/ack-frequency",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "bfd4f2"
    },
    {
      "name": "design",
      "description": "",
      "color": "B60205"
    },
    {
      "name": "needs-pr",
      "description": "",
      "color": "1D76DB"
    },
    {
      "name": "needs-discussion",
      "description": "",
      "color": "5319E7"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU1NDc2NjUzMDY=",
      "title": "Discuss whether this affects the max_ack_delay used in PTO",
      "url": "https://github.com/quicwg/ack-frequency/issues/1",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If it doesn't change it, we should say so.  If it allows it to be reduced, then we need to understand what the limits are(ie: it can't be lowered to 1us presumably?).\r\n\r\nAdmittedly, the way we're using max_ack_delay should be safe to assuming a 0 value, since the SRTT will accrue the excess.",
      "createdAt": "2020-01-09T19:09:49Z",
      "updatedAt": "2020-01-17T21:59:36Z",
      "closedAt": "2020-01-17T21:59:36Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NDc2NjY5MDE=",
      "title": "Make both parameters required and specify invalid values",
      "url": "https://github.com/quicwg/ack-frequency/issues/2",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it'll be easier to make both parameters required.  Not doing so saves 1 to 2 bytes, which is really not much in a frame I expect will be sent a few times a connection.\r\n\r\nAlso, I think 0 should be an invalid value for both params, and 1 should be invalid for the number of packets, though I can see someone arguing that point.",
      "createdAt": "2020-01-09T19:12:32Z",
      "updatedAt": "2020-01-17T20:29:05Z",
      "closedAt": "2020-01-17T20:29:05Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "#4 addresses these issues, with the exception that 1 is allowed for packet tolerance. I think that's actually useful for some startup schemes, so we shouldn't disallow it.",
          "createdAt": "2020-01-17T20:28:04Z",
          "updatedAt": "2020-01-17T20:28:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NDc2Njg2MTE=",
      "title": "Make both fields in the frame required",
      "url": "https://github.com/quicwg/ack-frequency/issues/3",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think it'll be easier to make both parameters required.  Not doing so saves 1 to 2 bytes, which is really not much in a frame I expect will be sent a few times a connection.  It also means the frame only needs one type value.\r\n\r\nAlso, I think 0 should be an invalid value for both params, and 1 should be invalid for the number of packets, though I can see someone arguing that point.",
      "createdAt": "2020-01-09T19:16:10Z",
      "updatedAt": "2020-01-09T19:16:29Z",
      "closedAt": "2020-01-09T19:16:29Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1NTE2NDA4MTc=",
      "title": "Frame should have its own sequence number",
      "url": "https://github.com/quicwg/ack-frequency/issues/5",
      "state": "CLOSED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently use PNs for ordering, but that runs afoul of requirements at the receiver specified in [https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.3-5](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.3-5).",
      "createdAt": "2020-01-17T21:30:10Z",
      "updatedAt": "2020-01-17T22:47:58Z",
      "closedAt": "2020-01-17T22:47:58Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU1NTE2NDE3MTQ=",
      "title": "Allow reordering-tolerant ack delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/6",
      "state": "CLOSED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Endpoints expect the connection to encounter reordering might want to indicate that the receiver should not send immediate acks on receiving a reordered packet.",
      "createdAt": "2020-01-17T21:32:42Z",
      "updatedAt": "2020-01-18T00:01:17Z",
      "closedAt": "2020-01-18T00:01:17Z",
      "comments": []
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU1NTMwNTc1NDQ=",
      "title": "Slow Start and Hystart need references",
      "url": "https://github.com/quicwg/ack-frequency/issues/14",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\"Starting a connection up quickly without inducing much queue is important for latency reduction, for both short and long flows. The sender often needs frequent acknowledgments during this phase; see slow start and hystart.\"\r\n\r\nThere's no description of them in this doc.  Slow start is in the recovery draft, but hystart is not, so we'd have to reference a non-QUIC RFC?",
      "createdAt": "2020-01-21T18:40:01Z",
      "updatedAt": "2020-01-31T02:50:22Z",
      "closedAt": "2020-01-31T02:50:22Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe paced chirping too.",
          "createdAt": "2020-01-21T23:47:20Z",
          "updatedAt": "2020-01-21T23:47:20Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An added nit to this: congestion controllers like BBR do not have a slow start / hystart phase exactly, but are still sensitive to ACKs early in the flow during \"Startup\". With a BBR congestion controller the ACKing interval early in the flow has a measurable effect on the time it takes to find the bottleneck bandwidth.\r\n\r\nMore generally I suspect this is true of pretty much every congestion controller that's trying to find an optimal congestion window. Given that, perhaps we need more general language here about the benefit of ACKs early in a flow, and then referencing slow start and hystart specifically?",
          "createdAt": "2020-01-23T22:48:31Z",
          "updatedAt": "2020-01-23T22:48:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "BBR has 'Startup', which is quite similar to slow start, so maybe flow startup a better general purpose term?\r\n\r\nI think we can remove the reference to hystart entirely, since I wouldn't expect decreasing ACK frequency to have a negative impact on it, particularly given QUIC's explicit ack delay.",
          "createdAt": "2020-01-23T23:13:48Z",
          "updatedAt": "2020-01-23T23:13:48Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU1NTQ0NDE1ODY=",
      "title": "Should this extension recommend an endpoint behavior?",
      "url": "https://github.com/quicwg/ack-frequency/issues/17",
      "state": "CLOSED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on [3304](https://github.com/quicwg/base-drafts/issues/3304) in the base draft, we have some confidence in a particular heuristic (default tolerance of 2 for the first 100 packets, followed by a tolerance of 10) which we know to work fairly well in multiple deployments serving \"typical\" Internet resources to typical users. Do we want to make that recommendation explicit, or otherwise give guidance in this extension?",
      "createdAt": "2020-01-23T22:22:04Z",
      "updatedAt": "2020-03-19T23:08:56Z",
      "closedAt": "2020-03-19T23:08:56Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's a good idea to describe the values for which we have experience, while encouraging experimentation. We don't need to _recommend_ the strategy, we just need to document it as an example strategy.",
          "createdAt": "2020-01-23T22:29:52Z",
          "updatedAt": "2020-01-23T22:29:52Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a section on considerations and maybe past experience would be very helpful.  I think it's going to be a bit of a challenge to write, but I'm happy to take a stab if no one else wants to.",
          "createdAt": "2020-01-25T00:02:21Z",
          "updatedAt": "2020-01-25T00:02:21Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "What I'd want to see is just a simple explanation of what a sender could do... I would not describe results from experience, since those are anecdotal and are going to change over time. This could be a fairly short section.",
          "createdAt": "2020-01-25T00:36:44Z",
          "updatedAt": "2020-01-25T00:36:44Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@janaiyengar @ianswett I can take a stab at writing something and we can go from there.",
          "createdAt": "2020-01-28T00:26:07Z",
          "updatedAt": "2020-01-28T00:26:07Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @mjoras !",
          "createdAt": "2020-01-28T00:29:15Z",
          "updatedAt": "2020-01-28T00:29:15Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do think the pitfalls of e.g. #25 should be conveyed in such \"cautionary\" text as well. I will submit a PR this week time permitting between interop.",
          "createdAt": "2020-02-03T07:11:00Z",
          "updatedAt": "2020-02-03T07:11:00Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU1NTQ1MjI3MzI=",
      "title": "Why is the response to reordering a TP?",
      "url": "https://github.com/quicwg/ack-frequency/issues/18",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Maybe it would be more consistent if this was a field on the ACK_FREQUENCY frame?",
      "createdAt": "2020-01-24T03:12:58Z",
      "updatedAt": "2020-02-03T16:23:11Z",
      "closedAt": "2020-02-03T16:23:11Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "I agree. Not only for consistency but also for practical benefits.\r\n\r\nFirstly, in many cases, the sender will only be able to tell if the path is going to have lots of reorders. Allowing the sender to alter the client behavior mid-connection would be beneficial, as that would allow the sender reduce the ACK rate when it disables packet number-based loss detection.\r\n\r\nThe second use case is for clustered servers sending different streams from different hosts. Packets being sent from such clustered servers would have reorder when there are multiple servers handling streams, but not when there is only server handling streams (consider the case where only one stream, or only one HTTP request is open). In such deployments, it is beneficial to have the capability of turning off reordering detection mid-connection.",
          "createdAt": "2020-01-24T06:30:24Z",
          "updatedAt": "2020-01-24T06:30:24Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> Firstly, in many cases, the sender will only be able to tell if the path is going to have lots of reorders. Allowing the sender to alter the client behavior mid-connection would be beneficial, as that would allow the sender reduce the ACK rate when it disables packet number-based loss detection.\r\n\r\nLet's assume here that peers might adjust their reordering threshold based on the amount of reordering they're seeing, i.e. that they will increase it from the default value of 3 to a higher value if they detect a lot of spurious retransmissions when using 3.\r\nIn that case, would it maybe make sense to define a threshold when to send an ACK for a reordered packet? For example, let's say packet N is missing, but N+1 is received. If you're using a high reordering threshold, you wouldn't care to receive an ACK for this event immediately. However, you'd still care to get an ACK when N+10 is received, because in that case your packet number-based loss detection will be able to quickly repair the loss of packet N.\r\n",
          "createdAt": "2020-01-24T06:40:51Z",
          "updatedAt": "2020-01-24T06:40:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@marten-seemann I agree that that's a possibility. At the same time, it could be well the case that simply turning off reordering detection and solely relying on the time-based loss recovery would be sufficient.",
          "createdAt": "2020-01-24T07:06:41Z",
          "updatedAt": "2020-01-24T07:06:41Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "@kazuho I can't really tell what makes sense from the point of a congestion control algorithm, but I'm wondering if it makes sense to specify something here that would allow a wide range of algorithms to get the kind of information that they deem useful.\r\nIf we made that field a varint instead of a bool (then we can also avoid the question of how we would encode a bool), you could still effectively disable ACKs for reordered packets by sending a very large value for that field, if you want to disable packet number-based loss recovery.",
          "createdAt": "2020-01-24T07:25:31Z",
          "updatedAt": "2020-01-24T07:25:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "When @janaiyengar and I were discussing this, we thought it was best to not make this part of the mechanism overly complex, hence the transport param.  Unfortunately, we have very little(or no) deployment experience in this area, so the TP was more of a future-proofing mechanism than one based on past experience.\r\n\r\nIf we were going to add a field, I'd suggest a max_reordering field where 0 indicates any reordering is tolerated and any other values indicate a max packet number gap before an immediate ACK is sent?  If you want immediate ACK upon reordering, you'd send 1.\r\n\r\nThat only adds a byte to the frame size in almost all cases, but I think should work well in a wide variety of use cases.  \r\n\r\nMy main concern is whether the implementation complexity increases more than the value it's providing?\r\n\r\n",
          "createdAt": "2020-01-24T23:57:29Z",
          "updatedAt": "2020-01-24T23:57:29Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's value in making this a field in the frame instead of a TP... as @ianswett noted, we used a TP because that seemed like the simplest approach, not necessarily the most flexible one.\r\n\r\nI agree with @marten-seemann that allowing for communicating a \"threshold\" has the most room for play with reordering robustness in the future. I'm not convinced that it'll get all that used, but if the receiver behavior is not much more complicated to implement, then I'm ok with specifying that.\r\n\r\nSo, here's a shot at defining receiver behavior. A receiver has to measure the degree of reordering and then decide whether to ack immediately or not.  This degree of reordering can be defined as follows: the distance of the received packet from the largest_received (for that PN space). Basically:\r\n\r\n```\r\nif (PN > LR):\r\n    if (PN - LR >= max_reordering): send immediate ack\r\nelse:\r\n    if (LR - PN >= max_reordering): send immediate ack\r\n```\r\n\r\nA couple of examples to see if this works out. Let's say LR is the largest_received packet number.\r\n\r\nA reordering distance of 2 means that LR+2 and larger or LR-2 and smaller will trigger an immediate ack. This seems ok. All distances greater than 2 also seem ok.\r\n\r\nReordering distance of 1 is a bit tricky. This distance means that if LR+1 is received, that triggers an immediate ack. Similarly, anything smaller than or equal to LR-1 will also trigger immediate ack (anything smaller than the largest received). The current reordering recommendation in the transport draft will have the receiver acking immediately on receiving LR-1, and we should be able to cover that case, so we should be able to express this value.\r\n\r\nBut this is a bit wonky, since LR+1 is basically the next expected, and this reordering value effectively turns into `ack every packet`. It would be nice to avoid this problem. We can do that by using Ian's suggestion of special casing the value 1: \"any reordering, as defined as a PN that does not increase the LR by 1, will trigger an ack.\"\r\n\r\nSimilarly, special casing the value 0 for disable immediate acking on reordering is useful.\r\n\r\nHaving worked through this, it doesn't seem that terrible. I'm ok with varint or single byte. I agree with @ianswett that the most usefulness will be in 1 byte, but I can see the value in leaving it open and uniform.\r\n\r\nThoughts?",
          "createdAt": "2020-01-25T01:17:00Z",
          "updatedAt": "2020-01-25T01:17:00Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "So the final algorithm becomes:\r\n```\r\nbool ShouldSendImmediateAck(uint LR, uint PN):\r\n    if (max_reordering == 0): return false\r\n    if (max_reordering == 1):\r\n        if (PN != LR+1): return true\r\n        else: return false\r\n\r\n    if (PN > LR):\r\n        if (PN - LR >= max_reordering): return true\r\n    else:\r\n        if (LR - PN >= max_reordering): return true\r\n\r\n    return false\r\n```",
          "createdAt": "2020-01-25T01:21:48Z",
          "updatedAt": "2020-01-25T01:21:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd rather have a varint for consistency, even if it's almost always a single byte.",
          "createdAt": "2020-01-25T01:38:46Z",
          "updatedAt": "2020-01-25T01:38:46Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "@janaiyengar, thank you for picking up my suggestion and writing the pseudo code.\r\nI'm not sure if just looking at the largest received is sufficient to properly cover all cases. Assume you receive packet `N`, packet `N+2`. At this point `LR = N+2`. Now you receive `N + max_reordering`. I would have assumed that it makes sense now to send an immediate ACK to help with the recovery of `N+1`, however, the algorithm doesn't capture that case.\r\n\r\nFurthermore, I was wondering about the negative branch (where `PN < LR`). This branch can only be taken if we sent an ACK earlier for exceeding the `max_reordering`. Assuming that ACK was received, the packet in question would already have been declared lost, so in that case sending an immediate ACK wouldn't make any difference. Is my understanding correct that the negative branch exists for the case in which the original ACK was lost?\r\n\r\nEncoding-wise, we might be able to simplify things a bit replacing `max_reordering` by `max_gap` (where a `max_gap` of 1 would be a `max_reordering` of 2). Then we could avoid special-casing the value of 1.\r\n\r\nI'm also wondering how many immediate ACKs you're supposed to send. Currently, the draft has some quite complicated conditions for this:\r\n> an endpoint SHOULD send an ACK frame immediately on receiving an ack-eliciting packet that is out of order. The endpoint MAY continue sending ACK frames immediately on each subsequently received packet, but the endpoint SHOULD return to acknowledging every other packet within a period of 1/8 x RTT, unless more ack-eliciting packets are received out of order.\r\n\r\nDo we need some similar advice here? Or do we need to make it configurable?\r\n",
          "createdAt": "2020-01-25T05:42:51Z",
          "updatedAt": "2020-01-25T05:42:51Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann on the point about how many immediate ACKs to send, I believe we should only send one, so I have an issue(#3357) and PR(#3361) to change the text you quoted.\r\n\r\nIn terms of the 'negative branch' as you're describing it, the idea is that it's very possible the packet has not yet been declared lost yet, even though the ACK has arrived.  If they're using this reordering tolerant setting, it seems likely they're tolerant to more reordering than a typical sender.  For example, it could be because they have adaptive packet threshold loss detection and the threshold has been increased substantially due to observing past reordering.",
          "createdAt": "2020-01-25T15:48:36Z",
          "updatedAt": "2020-01-25T15:48:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We definitely need to have a few people ship this reordering tolerant feature before we finalize this draft.  I'm quite confident in everything else in the draft, but I'm fairly unsure about exactly how this can and should be used.  I'm also not yet sure packet threshold is actually better than time.  It seems more appealing, but I think it depends on the use case.\r\n\r\nI'm also concerned it adds non-trivial implementation complexity.  Implementations already have a max_ack_delay and a number of packets before sending an immediate ACK, so this is just adding a mechanism to change those thresholds during the connection.  However, this reordering feature may end up substantially changing the code to send ACKs.  I'd be pretty sad if a bunch of implementations didn't implement the draft because they didn't want to deal with the extra complexity.",
          "createdAt": "2020-01-25T21:30:39Z",
          "updatedAt": "2020-01-25T21:30:39Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, @ianswett, which is why I wanted to go through and see if we could define simple enough behavior that is useful.\r\n\r\nI don't think we want to be perfect with the detection, but reasonable. I'll think of simplifications to this, but we want to make sure that we dont make this unnecessarily ornate. I am concerned that this threshold becomes another footgun, since we really don't have a good recommendation for how to set it.\r\n\r\nThe primary property we want is a dynamic way to indicate to the peer to not send immediate acks on reordering. Simply moving the TP to the frame will give us that.\r\n\r\nI am increasingly leaning towards just calling this a boolean instead of a threshold. I will plan to write that up by tomorrow. Any strong objections?",
          "createdAt": "2020-02-01T22:28:05Z",
          "updatedAt": "2020-02-01T22:28:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Boolean as a frame field works perfectly fine for my use case.",
          "createdAt": "2020-02-02T02:34:01Z",
          "updatedAt": "2020-02-02T02:34:01Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU1NTcxMDk4MzQ=",
      "title": "Use underscore in frame name",
      "url": "https://github.com/quicwg/ack-frequency/issues/19",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [],
      "body": "Use `ACK_FREQUENCY` instead of `ACK-FREQUENCY` following naming convention in the transport draft.",
      "createdAt": "2020-01-29T20:54:47Z",
      "updatedAt": "2020-01-31T02:49:44Z",
      "closedAt": "2020-01-31T02:49:44Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU1NTcxMTc3OTE=",
      "title": "min/max delay clarification",
      "url": "https://github.com/quicwg/ack-frequency/issues/20",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've re-read the draft a few times, but I still want to ask you to verify my understanding, just to be sure:\r\n\r\n1. Each side informs the other of **its own** minimum and maximum ACK delay values using the (new) `min_ack_delay` and `max_ack_delay` transport parameters.\r\n\r\n2. The `Update Max Ack Delay` value changes the **peer's** maximum ACK delay.  It must not be smaller than the `min_ack_delay` advertised by the peer.",
      "createdAt": "2020-01-29T21:11:17Z",
      "updatedAt": "2020-02-27T23:40:06Z",
      "closedAt": "2020-02-27T23:40:06Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@dtikhonov : Yes, that is correct. I know it can be a bit confusing. Hope the text is clear on this though.",
          "createdAt": "2020-01-30T21:09:45Z",
          "updatedAt": "2020-01-30T21:09:45Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@dtikhonov : I'm closing this issue. If you think we ought to clarify this in the text further, please re-open.",
          "createdAt": "2020-02-27T23:40:06Z",
          "updatedAt": "2020-02-27T23:40:06Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU1NTcxMzQ4MDM=",
      "title": "Specify in which packets ACK_FREQUENCY may appear",
      "url": "https://github.com/quicwg/ack-frequency/issues/22",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "See Table in [Section 12.4](https://tools.ietf.org/html/draft-ietf-quic-transport-25#section-12.4) of the transport draft.",
      "createdAt": "2020-01-29T21:46:27Z",
      "updatedAt": "2021-09-10T16:15:48Z",
      "closedAt": "2021-09-10T16:15:48Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "We recommend endpoints to ACK Initial and Handshake packets immediately (see https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-13.2.1-1). I do not think we need to change that, and therefore my view is that use of ACK_FREQUENCY frames can (and should) be limited to 1-RTT.",
          "createdAt": "2020-01-30T00:06:06Z",
          "updatedAt": "2020-01-30T00:10:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, I think we just need to specify that.",
          "createdAt": "2020-01-30T00:26:07Z",
          "updatedAt": "2020-01-30T00:26:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Just a note that, new TPs are required to clarify if the TP is to be remembered (https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#section-7.4.1-3).\r\n\r\nBased on the understanding that the use of the ACK_FREQUENCY frame will be limited to 1-RTT packets, I assume that remembering the min_ack_delay TP will be prohibited.",
          "createdAt": "2020-10-22T05:23:59Z",
          "updatedAt": "2020-10-22T05:23:59Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point @kazuho I do not believe min_ack_delay should be remembered, since it has no use prior to handshake completion.",
          "createdAt": "2020-10-22T06:38:07Z",
          "updatedAt": "2020-10-22T06:38:07Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We recommend endpoints to ACK Initial and Handshake packets immediately\r\n\r\n> Based on the understanding that the use of the ACK_FREQUENCY frame will be limited to 1-RTT packets\r\n\r\nI agree that ACK_FREQUENCY should not apply to Initial and Handshake packets. That doesn't mean that we need to limit ACK_FREQUENCY to 1-RTT packets though, it could apply to 0-RTT packets as well, if peers are required to remember the value of the TP. The client could then send an ACK_FREQUENCY in 0-RTT.\r\n\r\nI don't have a strong preference in either direction, but preventing a flood of ACKs for 0-RTT packets sounds like it could potentially be useful.",
          "createdAt": "2021-01-11T07:18:59Z",
          "updatedAt": "2021-01-11T07:18:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Considering our track record of allowing most frames to be sent in 0-RTT, I am fine with allowing the transmission of ACK_FREQUENCY frames in 0-RTT.\r\n\r\nOTOH, I do not think we should require endpoints to retain min_ack_delay TP across resumptions. That would essentially prohibits client from sending ACK_FREQUENCY frames in 0-RTT.",
          "createdAt": "2021-01-11T07:29:45Z",
          "updatedAt": "2021-01-11T07:29:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho Your two statements seem to contradict each other. If we allow ACK_FREQUENCY in 0-RTT, peers need to remember the value of the TP. If peers are not required to remember the value of the TP, ACK_FREQUENCY can't be sent in 0-RTT, otherwise a client would risk a PROTOCOL_VIOLATION if a server disabled the extension.",
          "createdAt": "2021-01-11T07:34:56Z",
          "updatedAt": "2021-01-11T07:34:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@marten-seemann That's a good point. And as you might have already observed, even if the client remembered min_ack_delay, it might still not be possible to send an ACK_FREQUENCY frame in 0-RTT. That's because max_ack_delay would be unknown.\r\n\r\nI think we are reaching consensus that clients would not send ACK_FREQUENCY frames in 0-RTT, even if the specification allowed that?",
          "createdAt": "2021-01-11T11:33:49Z",
          "updatedAt": "2021-01-11T11:33:49Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @marten-seemann That's a good point. And as you might have already observed, even if the client remembered min_ack_delay, it might still not be possible to send an ACK_FREQUENCY frame in 0-RTT. That's because max_ack_delay would be unknown.\r\n\r\nNow I'm a bit confused. In my mind, this is how this extension works (describing it using \"client\" and \"server\" for added clarity, it works the same way in the opposite direction):\r\nThe client declares a max_ack_delay in the transport parameters. When generating acknowledgements, the server will then make sure that every ACK is generated within that time frame. When the client sends an ACK_FREQUENCY frame, it instructs the server to discard the previous max_ack_delay value and use the one encoded in the frame instead.\r\n\r\nAssuming that my understanding is correct, the fact that the client hasn't received the server's max_ack_delay should be irrelevant when considering whether we want to send this frame in 0-RTT packets. Furthermore, the fact that the ClientHello has to be received before the server can decode any 0-RTT packet would guarantee that the server has processed the client's transport parameters before it is able to process any ACK_FREQUENCY frame.",
          "createdAt": "2021-01-11T11:47:01Z",
          "updatedAt": "2021-01-11T11:47:01Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett and I chatted about this; summarizing. An endpoint's ACK_FREQUENCY_FRAME updates the received max_ack_delay. This makes all situations where an endpoint sends an ACK_FREQUENCY_FRAME without receiving the peer's max_ack_delay problematic. Since a client does not remember the peer's max_ack_delay, sending an ACK_FREQUENCY_FRAME that updates it makes little sense.\r\n\r\nWe should disallow ACK_FREQUENCY_FRAMEs in 0-RTT packets because a client does not have the base value which it wants to update with this frame until 1-RTT keys are established.",
          "createdAt": "2021-07-12T17:37:37Z",
          "updatedAt": "2021-07-12T17:37:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "And we agree with @kazuho that #40 is intertwined with this issue, since if the transport parameter is not remembered, you can't send the ACK_FREQUENCY frame.",
          "createdAt": "2021-07-12T17:49:00Z",
          "updatedAt": "2021-07-12T17:49:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "My preference here is \"application\" packet number space.\r\n\r\nThis means that the transport parameter needs to be remembered.  It also means that - because max_ack_delay is not remembered - that you have to avoid exceeding the max_ack_delay default (and permit that variance as a server if you set a lower value for max_ack_delay).",
          "createdAt": "2021-07-27T21:01:20Z",
          "updatedAt": "2021-07-27T21:02:05Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "My real issue is whether the frames might appear before the TP negotiation has concluded. The client should not send ACK FREQUENCY frames before that. I think this naturally precludes sending ACK FREQUENCY in 0-RTT, but there might be corner cases in which the client knows the result of the TP negotiation before it has access to the 1-RTT keys -- for example if some of the crypto processing is going on in a crypto offload engine. If we are firm on negotiation, then we don't need to make a statement about 0RTT vs 1RTT.",
          "createdAt": "2021-07-27T21:10:11Z",
          "updatedAt": "2021-07-27T21:10:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@huitema I'm not sure if that follows the design of RFC 9000.\r\n\r\nFor frames that can be sent in 0-RTT, RFC 9000 requires endpoints to remember and reuse the value of the Transport Parameters:\r\n> When sending frames in 0-RTT packets, a client MUST only use remembered transport parameters; importantly, it MUST NOT use updated values that it learns from the server's updated transport parameters or from frames received in 1-RTT packets. ([section 7.4.1 of RFC 9000](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1-12))",
          "createdAt": "2021-07-28T06:52:35Z",
          "updatedAt": "2021-07-28T06:52:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Another potential option here in support of the basic design: this document could require that the value of max_ack_delay be remembered alongside min_ack_delay, (only)? for the generation of ACK_FREQUENCY frames.",
          "createdAt": "2021-07-28T07:03:11Z",
          "updatedAt": "2021-07-28T07:03:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson Would you mind elaborate why your implementation cannot prohibit frames being sent in 0-RTT packets from being affected by TPs other than remembered ones?\r\n\r\nRFC 9000 states that _when sending frames in 0-RTT packets, a client MUST only use remembered transport parameters_, and that _the definition of a new transport parameter MUST specify whether storing the transport parameter for 0-RTT is mandatory, optional, or prohibited_ ([section 7.4.1](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1)).\r\n\r\nSo it seems to me that, for Transport parameters that are prohibited to be remembered, QUIC stacks are expected to be capable of prohibiting those parameters to be used when sending frames using 0-RTT packets.\r\n\r\nIt seems to me that you are against us building extensions on that guidance.",
          "createdAt": "2021-07-28T07:13:34Z",
          "updatedAt": "2021-07-28T07:13:34Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I think there is broad support for not sending ACK_FREQUENCY frames before the negotiation completes. In response to the comment from @kazuho, this requires that \"storing the transport parameter for 0-RTT is prohibited.\" If we do that, we also satisfy the requirement stated by @martinthomson that 0-RTT processing be pretty much the same as 1-RTT processing: there is no new difference between 0-RTT and 1-RTT, in both cases the transport can only send the frame if the peer has explicitly accepted them.",
          "createdAt": "2021-07-28T17:18:46Z",
          "updatedAt": "2021-07-28T17:18:46Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @kazuho and @huitema I agree that if we prohibit storing min_ack_delay, ACK_FREQUENCY can't be sent in 0-RTT, and I believe that should solve @martinthomson issue?\r\n\r\nStoring BOTH min_ack_delay and max_ack_delay is a direction I'd really rather avoid.  ",
          "createdAt": "2021-07-28T20:16:20Z",
          "updatedAt": "2021-07-28T20:16:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "This works to ensure that there are no surprises for servers. But it doesn't prevent clients from sending the frame in 0-RTT. Our stack will apply transport parameters after receiving them. This is before handshake completion, so if we are still sending 0-RTT, we might send the frame. I don't believe that we will in practice, due to the logic we use for sending it. That logic is something that might change, so there are no strong guarantees.\r\n\r\nI do think that this is a good solution, I just want to make the consequences clear.",
          "createdAt": "2021-07-31T23:48:43Z",
          "updatedAt": "2021-07-31T23:48:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson If we are to prohibit min_ack_delay from being remembered, I do not think we can allow them to be sent in 0-RTT. \r\n\r\nRequoting from RFC 9000, _when sending frames in 0-RTT packets, a client MUST only use remembered transport parameters_, and that _the definition of a new transport parameter MUST specify whether storing the transport parameter for 0-RTT is mandatory, optional, or prohibited_ ([section 7.4.1](https://quicwg.org/base-drafts/rfc9000.html#section-7.4.1)).\r\n\r\nAm I missing something?\r\n\r\nAlso, I would point out that, even for remembered TPs, QUIC stacks are required to refrain from using the newly received ones in 0-RTT packets. For example, if the remembered value of MAX_STREAMS is 0 and the newly received value is 4, an endpoint is forbidden to open _any_ stream in 0-RTT even _after_ receiving the transport parameters. It is only when you switch to using 1-RTT packets that the newly received transport parameter is applied.\r\n\r\nFor your implementation, wouldn't it be possible to use the same latch for ack_frequency?",
          "createdAt": "2021-08-01T22:08:04Z",
          "updatedAt": "2021-08-01T22:08:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Oh, whoops.  We don't have that latch.  We'll probably open 4 streams if initial_max_streams_xxx is 4 in the handshake and we remembered 0.\r\n\r\nIn any case, we can probably add a latch.  It might even make the code simpler.",
          "createdAt": "2021-08-02T05:18:55Z",
          "updatedAt": "2021-08-02T05:18:55Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU1NTg3Njk1NDE=",
      "title": "what between false start and handshake done?",
      "url": "https://github.com/quicwg/ack-frequency/issues/25",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "I found an interesting regression when implementing the delayed ack extension. The extension allows the sender of the data to control the max ack delay and the ack gap. In general that's a good idea, but not for the 2 RTT of the connection. Once the client obtains the 1RTT key, it will start receiving data sent by the server in \"false start\". At that point the client has assessed the RTT of the connection, but the server has not. The \"max ack delay\" sent by the server is a guess based on statistics. It will typically be longer than recommended values like RTT/4. The effect is that the first ACKs are sent too late, which  has a cascading effect with some congestion control algorithms.\r\n\r\nMy fix was to use the values locally computed by the client until the session is confirmed and the server can send accurate \"ack frequency\" frames. Not sure whether we should have text about that in the draft.",
      "createdAt": "2020-02-02T22:36:49Z",
      "updatedAt": "2021-09-10T16:23:50Z",
      "closedAt": "2021-09-10T16:23:50Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not completely clear on the details here, so hopefully you can clarify.\r\n\r\nIs the server sending an ACK_FREQUENCY frame in 0.5RTT before it has any RTT samples?  If so, yes I would say that's a bad idea and we should add a SHOULD NOT to advise against that.  And the regression is that slow start is slowed down substantially vs the default behavior of sending an ACK every 2 packets?  Or is there another regression?\r\n\r\nPossibly this issue is a variation on #17 about recommendations and potential pitfalls of this extension frame?",
          "createdAt": "2020-02-03T00:28:26Z",
          "updatedAt": "2020-02-03T00:28:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "At 0.5 RTT, the server will start sending data frames: HTTP settings for example, or maybe responses to client requests in 0-RTT packets. \r\n\r\nAs you say, the server should not send an ACK FREQUENCY frame in 0.5RTT before it has any RTT samples. Let's assume it doesn't.\r\n\r\nThe client knows that Min Ack Delay has been negotiated. In that case, my first implementation of the extension was completely deferring to the server, and just setting Ack Delay Max to the parameter advertised by the server. After all, the draft does says that the ACK FREQUENCY frame carries _an update to the peer's \"max_ack_delay\" transport parameter_. That was be by the book. But it was also causing regressions in a number of performance tests, because the value in the TP is typically an upper bound. The acks were sent too late, the connection was ramping up too slowly.",
          "createdAt": "2020-02-03T00:57:48Z",
          "updatedAt": "2020-02-03T00:57:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, presumably the client is setting \"Packet Tolerance\" to a value larger than 2 in its ACK_FREQUENCY frame?  If so, that makes sense.\r\n\r\nIn the \"Motivations\" section, the existing draft says:\r\n\"Starting a connection up quickly without inducing excess queue is important for latency \r\n reduction, for both short and long flows. The sender often needs more frequent \r\n acknowledgments during this phase.\"\r\n\r\nBut maybe there needs to be more cautionary text later in the draft, and less text in \"Motivations\"?",
          "createdAt": "2020-02-03T01:27:17Z",
          "updatedAt": "2020-02-03T01:27:17Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: the issue here seems to be that in an interpretation of the mechanism, the client could change its behavior after receiving `min_ack_delay` but before receiving an ACK-FREQUENCY frame. This should not happen... the goal of `min_ack_delay` is to negotiate future use of ACK-FREQUENCY frames. Until an ACK-FREQUENCY frame is received, an endpoint continues with RFC 9000 behavior. We will add text to this effect.\r\n\r\n@huitema, does this work for you?",
          "createdAt": "2021-07-19T20:22:52Z",
          "updatedAt": "2021-07-19T20:24:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "@janaiyengar yes, that makes sense. I will check that the picoquic code does that.",
          "createdAt": "2021-07-20T19:39:13Z",
          "updatedAt": "2021-07-20T19:39:13Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU1NTkwMTAzMzM=",
      "title": "min_ack_delay=0 in TP parameter ",
      "url": "https://github.com/quicwg/ack-frequency/issues/26",
      "state": "CLOSED",
      "author": "junhochoi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Values of 0 and 2^24 or greater are invalid\r\n\r\nI think min_ack_delay=0 should be allowed? It means there is no delay sending ack, which is a current behavior.",
      "createdAt": "2020-02-03T11:07:20Z",
      "updatedAt": "2020-02-06T07:11:18Z",
      "closedAt": "2020-02-06T07:11:18Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "0 is equivalent to 1 as a value for the \"Packet Tolerance\" field I believe, so I agree that declaring it invalid seems unnecessary.  Also, 0 and 1 are extremely similar given this is in microseconds, and 1 is valid.",
          "createdAt": "2020-02-03T11:11:48Z",
          "updatedAt": "2020-02-03T11:11:48Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "0 and 1 are different, since 0 is immediate, and 1 involves a timer. Though, yeah, it seems silly to disallow immediate.",
          "createdAt": "2020-02-06T07:10:58Z",
          "updatedAt": "2020-02-06T07:10:58Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU1NjA4MTgzMDI=",
      "title": "Packet Tolerance is a non-obvious name",
      "url": "https://github.com/quicwg/ack-frequency/issues/27",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial"
      ],
      "body": "By itself, it's not obvious(at least to me), what the field indicates without reading the description.\r\n\r\nAn alternate suggestion is \"Packet threshold\", since recovery calls it \"Packet threshold loss detection\".\r\n \r\n This is pretty clearly editorial.",
      "createdAt": "2020-02-06T07:00:59Z",
      "updatedAt": "2021-07-29T14:39:25Z",
      "closedAt": "2021-07-29T14:39:25Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "The use of it in loss detection is why I didn't call it packet threshold, to avoid confusion. But I agree that packet threshold is more natural... if you don't think this will cause confusion, I'm fine with it.",
          "createdAt": "2020-02-06T07:08:03Z",
          "updatedAt": "2020-02-06T07:08:03Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, how about \"Update Packet Threshold\" to align with \"Update Max Ack Delay\"?",
          "createdAt": "2020-02-06T07:14:05Z",
          "updatedAt": "2020-02-06T07:14:05Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "s/Update/New/?",
          "createdAt": "2020-02-06T08:12:52Z",
          "updatedAt": "2020-02-06T08:12:52Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Both SGTM",
          "createdAt": "2020-02-06T08:34:47Z",
          "updatedAt": "2020-02-06T08:34:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, let me think more, after starting a PR, I think packet threshold would be confusing.",
          "createdAt": "2020-02-06T08:46:16Z",
          "updatedAt": "2020-02-06T08:46:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Do we need \"update_\" in every field name? That seems excessive to me.\r\n\r\nIf we do think that we'd need to have the word somewhere, I think my preference goes to to changing the name of the frame to \"update_ack_frequency,\" and refrain from having \"update_\" in each field name.",
          "createdAt": "2020-04-07T01:51:26Z",
          "updatedAt": "2020-04-07T01:51:26Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "[Currently](https://tools.ietf.org/html/draft-iyengar-quic-delayed-ack-00), the draft states:\r\n\r\n```\r\n   Packet Tolerance:  A variable-length integer representing the maximum\r\n      number of ack-eliciting packets after which the receiver sends an\r\n      acknowledgement.  A value of 1 will result in an acknowledgement\r\n      being sent for every ack-eliciting packet received.  A value of 0\r\n      is invalid.\r\n```\r\n\r\nWe see that \"packet\" is a unit of measure; what it measures is the threshold after which an ACK is sent.  A better name would be _ACK-eliciting threshold_.  The fact that it represents a number of packets does not have to be in the name itself.",
          "createdAt": "2020-04-07T12:57:12Z",
          "updatedAt": "2020-04-07T12:57:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "ACK-eliciting threshold does seem better.  Or even Ack threshold.\r\n\r\n@kazuho changing the frame to UPDATE_ACK_FREQUENCY and then removing update_ from the names WFM.",
          "createdAt": "2020-04-07T18:33:07Z",
          "updatedAt": "2020-04-07T18:33:07Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "How about _ACK_FREQUENCY_UPDATE_, then?  This way, you can still write the frame type as an abbreviation, `0xAFu`!",
          "createdAt": "2020-04-07T18:40:44Z",
          "updatedAt": "2020-04-07T18:40:44Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Do we need \"update\" at all?\r\n\r\nI think we can simply say that an \"ACK_FREQUENCY\" frame updates how frequent ACK frames are sent.\r\n\r\nConsider MAX_STREAMS. The frame name does not include \"update\". It's implied. The same goes to the field name. The name is simply \"maximum streams.\" We can follow that convention.",
          "createdAt": "2020-04-07T19:05:54Z",
          "updatedAt": "2020-04-07T19:05:54Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with @kazuho on not including UPDATE in the name. Updating is implicit in the semantics of this frame, as it is not an informative frame.\r\n\r\nI also prefer ACK-eliciting threshold to just ACK threshold. ACK-eliciting threshold makes it clear that the threshold is against ACK-eliciting packets, which are well-defined.",
          "createdAt": "2020-04-29T16:38:34Z",
          "updatedAt": "2020-04-29T16:38:34Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Both changes SGTM (remove \"Update\" and change to \"Ack-eliciting Threshold\")",
          "createdAt": "2021-07-12T17:40:17Z",
          "updatedAt": "2021-07-12T17:40:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "One potential issue with changing 'Update Max Ack Delay' to 'Max Ack Delay' is it could be confused with the 'max_ack_delay' transport param.",
          "createdAt": "2021-07-12T17:44:08Z",
          "updatedAt": "2021-07-12T17:44:08Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we do need clarity here. An endpoint advertizes its own max_ack_delay in the TP, but the ACK-FREQUENCY frame is a command or request to the peer to change the peer's advertized value.",
          "createdAt": "2021-07-19T20:31:28Z",
          "updatedAt": "2021-07-19T20:31:28Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@janaiyengar and I were talking and are worried about confusion on this one.\r\n\r\nOne suggestion is \"Request Max Ack Delay\"",
          "createdAt": "2021-07-19T20:32:21Z",
          "updatedAt": "2021-07-19T20:32:21Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1NjIwMDQxNTQ=",
      "title": "Make it more clear that implementations can send less ACKs",
      "url": "https://github.com/quicwg/ack-frequency/issues/30",
      "state": "OPEN",
      "author": "rpaulo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "As discussed with @janaiyengar a couple days ago, I think the draft should make it clear that implementations are allowed to send less ACKs than the requested \"packet tolerance\".\r\n\r\n> 6.3.  Batch Processing of Packets\r\n>   For performance reasons, an endpoint can receive incoming packets\r\n>   from the underlying platform in a batch of multiple packets.  This\r\n>   batch can contain enough packets to cause multiple acknowledgements\r\n>   to be sent.\r\n>\r\n>   To avoid sending multiple acknowledgements in rapid succession, an\r\n>   endpoint MAY process all packets in a batch before determining\r\n>   whether a threshold has been met and an acknowledgement is to be sent\r\n>   in response.\r\n\r\nThe last paragraph is a bit unclear since \"threshold\" is undefined.  I think we should just say that:\r\n\r\n1) it MAY process all packets in a batch (already there)\r\n2) it MAY send less ACKs when it has finished processing the batch\r\n\r\n",
      "createdAt": "2020-02-08T11:02:23Z",
      "updatedAt": "2021-07-27T21:01:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU1OTYzMDU2MzM=",
      "title": "ignore_order vs. inducing ack on PTO (aka IMMEDIATE_ACK)",
      "url": "https://github.com/quicwg/ack-frequency/issues/34",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "When sending a PTO packet, a sender wants to induce an immediate ACK. The only trick I know to induce such an ACK is intentionally skip the packet number.\r\n\r\nHowever, the problem of that approach is that it relies on the receiver not ignoring reorders.\r\n\r\nWhen an ACK_FREQUENCY frame previously sent had set the `ignore_order` bit, then it become impossible for a sender to induce an immediate ACK when sending a PTO packet.\r\n\r\nAt the moment, the only solution is to bundle an ACK_FREQUENCY packet in each PTO packet, but that seems like a bit of unnecessary overhead to me. Should we have a dedicated frame for inducing immediate ACKs instead?",
      "createdAt": "2020-04-08T04:48:29Z",
      "updatedAt": "2021-09-08T12:30:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an option.  Another option is to revisit the max_reordering idea discussed in #18.\r\n\r\nIf the max reordering was 5, then you could skip 5 PNs.  I do feel like it'd be nice to allow specifying an int for max reordering, since that matches up with adaptive packet threshold loss detection, but as I expressed in #18, I think getting the details right are deceptively difficult, so I'm torn.",
          "createdAt": "2020-04-08T14:00:56Z",
          "updatedAt": "2020-04-08T14:00:56Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This does seem like a real problem. I like the idea of a single \"ELICIT_ACK\" type frame. With one byte a sender could effectively mark its PTOs ensuring they get an ACK without relying on the trick.\r\n\r\nAn explicit frame is also easier to implement for the sender than the packet number skipping.",
          "createdAt": "2020-04-29T16:49:47Z",
          "updatedAt": "2020-04-29T16:49:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There's quite a bit of discussion on this on the tcpm mailing list at the moment, ie: https://mailarchive.ietf.org/arch/browse/tcpm/?gbt=1&index=OlHjbLuquYYe7twVPuZBHqbBph8\r\n\r\nI'm increasingly thinking it's worth using an unused protected bit in the header for this.  It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n\r\nFor example, I believe this could allow an implementation to not include max_ack_delay in PTO if it set the \"ACK-pull\"(or whatever it's called) bit on the final packet.  That already seems possible if more than the threshold number of ack-eliciting packets are outstanding.",
          "createdAt": "2020-05-02T20:51:35Z",
          "updatedAt": "2020-05-02T20:51:35Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer?  If we can decide, then I'll be happy to write a PR(or @kazuho can).\r\n\r\nBesides PTO, a use case would be making the last packet before becoming app-limited elicit an immediate ACK.  This could allow skipping max_ack_delay for all PTOs(see #37), though always doing it could be a bit much in some cases.  For example, browsers commonly send a series of requests, but to the transport it seems app-limited between them, because it doesn't know the browser has another request to send.\r\n\r\nIt might be useful for 'chirping' as well, but I've never tried that, so it's mostly speculation.",
          "createdAt": "2020-05-03T20:34:58Z",
          "updatedAt": "2020-05-03T20:36:04Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm increasingly thinking it's worth using an unused protected bit in the header for this. It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n\r\nWe don't currently have any intention of deploying them either, and I think that's unlikely to change. I haven't seen a lot of good evidence that they are terribly helpful, and content providers don't seem to have a good incentive for implementing it. \r\n\r\n> I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer? If we can decide, then I'll be happy to write a PR\r\n\r\nFor us at least, the difference in complexity for a frame versus a bit in the header is negligible. A frame is actually be slightly easier to implement and losing a byte here and there isn't so bad.",
          "createdAt": "2020-05-05T23:32:12Z",
          "updatedAt": "2020-05-06T00:00:01Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've thought more about this, and I think most of the time a 1-byte frame would be acceptable, but it definitely adds some implementation complexity, so I'd be curious which design others prefer?\r\n\r\nI strongly prefer using the header bit. Although it will be a bit more work to implement, the fact that I won't end up with a 1-byte STREAM frame that I have to split off at the end of the packet will be worth the effort.",
          "createdAt": "2020-05-06T01:02:48Z",
          "updatedAt": "2020-05-06T01:02:48Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": ">>   I'm increasingly thinking it's worth using an unused protected bit in the header for this. It'd end up competing with the 2-bit packet loss measurements, but given those are experimental and may never be widely deployed, I think it might be worth it.\r\n>\r\n> We don't currently have any intention of deploying them either, and I think that's unlikely to change. **I haven't seen a lot of good evidence that they are terribly helpful**\r\n\r\nIs testimony of network operators not taken as evidence?  I remember a line of people, from different companies -- BT, ATT, and so on, at IETF 101 practically begging for some information in QUIC packets to be exposed for monitoring and troubleshooting.",
          "createdAt": "2020-08-07T11:59:47Z",
          "updatedAt": "2020-08-07T11:59:47Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> I strongly prefer using the header bit. Although it will be a bit more work to implement, the fact that I won't end up with a 1-byte STREAM frame that I have to split off at the end of the packet will be worth the effort.\r\n\r\nI do not see anyone propose a 1-byte *STREAM* frame.  I believe what is meant is a new frame type.\r\n\r\nIf anything, using a new frame type to elicit an ACK is easier than using a header bit, as it involves fewer parts of the code to change.",
          "createdAt": "2020-08-07T12:08:36Z",
          "updatedAt": "2020-08-07T12:08:36Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I do not see anyone propose a 1-byte STREAM frame. I believe what is meant is a new frame type.\r\n\r\nNobody is proposing a 1-byte STREAM frame (you can't just make up stream data anyway). \r\nThe problem is that a new frame would consume bytes (or probably one byte) in the packet payload. Given that you set this signal on a PTO, and PTOs are often retransmissions of packets, this would require you to repackage (and, most likely, cut off a single byte from a STREAM frame). Using a header bit would solve that problem.",
          "createdAt": "2020-08-07T12:29:40Z",
          "updatedAt": "2020-08-07T12:29:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@janaiyengar and I discussed this and there are number of ways to fix this, but given this issue of not being able to elicit an immediate ACK by skipping packet numbers is introduced by the draft, we feel it's important it be fixed in some way.\r\n\r\nOne more option is new STREAM frame codepoints that elicit an immediate ACK.",
          "createdAt": "2021-07-19T20:50:57Z",
          "updatedAt": "2021-07-19T20:50:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm ready to write a PR, but I'd appreciate thoughts on whether the existing PING frame should be repurposed or we should add a new frame(ACK, PONG, etc).\r\n\r\nI lean towards a new frame, since there are enough code-points and I believe there are use cases for the existing PING frame that does not elicit an immediate ACK.",
          "createdAt": "2021-07-31T01:29:37Z",
          "updatedAt": "2021-07-31T01:29:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> I lean towards a new frame, since there are enough code-points and I believe there are use cases for the existing PING frame that does not elicit an immediate ACK.\r\n\r\n+1. While I would not be opposed to repurposing the existing PING frame, I do not see the necessity of doing that. Let's simply consume one code point of the remaining 33.",
          "createdAt": "2021-08-02T02:05:36Z",
          "updatedAt": "2021-08-02T02:05:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, now for bikeshedding time.\r\n\r\nSome possible names:\r\n ACK_ME\r\n ACK_PULL (from TCP)\r\n FAST_ACK\r\n PONG",
          "createdAt": "2021-08-02T15:36:11Z",
          "updatedAt": "2021-08-02T15:36:11Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Putting on my bikeshedding hat:\r\n\r\nI don't think we should prefix the frame name with ACK_ since that almost makes it looks like yet another variant of the ACK frame.\r\n\r\nThe \"pull\" TCP terminology is fine (e.g. PULL_ACK) but we could also be more explicit with something like SOLICIT_ACK.",
          "createdAt": "2021-08-02T18:22:44Z",
          "updatedAt": "2021-08-02T18:22:44Z"
        },
        {
          "author": "msvoelker",
          "authorAssociation": "NONE",
          "body": "SCTP has something similar and calls it SACK-IMMEDIATELY (RFC 7053).",
          "createdAt": "2021-08-04T13:56:09Z",
          "updatedAt": "2021-08-04T13:56:09Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I'd be happy with ACK_IMMEDIATELY or IMMEDIATE_ACK",
          "createdAt": "2021-08-04T14:48:01Z",
          "updatedAt": "2021-08-04T14:48:01Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For those two options I'd prefer IMMEDIATE_ACK for the same reasoning as above -- so it appears less like an ACK variant.",
          "createdAt": "2021-08-04T21:06:43Z",
          "updatedAt": "2021-08-04T21:06:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "IMMEDIATE_ACK sounds good to me. Alternatively, I'd be also fine with something like ACK_NOW.",
          "createdAt": "2021-08-04T21:14:56Z",
          "updatedAt": "2021-08-04T21:14:56Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "IMMEDIATE_ACK it is, PR coming.",
          "createdAt": "2021-09-08T12:19:34Z",
          "updatedAt": "2021-09-08T12:19:34Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU2MDI1NDQyMjY=",
      "title": "Replace Ignore Order with Packet Threshold",
      "url": "https://github.com/quicwg/ack-frequency/issues/35",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "design",
        "needs-discussion"
      ],
      "body": "Issue #34 points out that if ignore_order is true, there's no way to get an immediate ACK(for PTO or otherwise).\r\n\r\nThis proposal is very similar to that discussed in #18, but I believe I can specify both how to implement it and how it could be used better than I was able to previously.\r\n\r\nI believe there's a straightforward use case every implementation can benefit from, which is communicating one's packet threshold for loss detection.\r\n\r\nI previously presented data at maprg which showed about half of reordering is twiddles(reorder of 1), so having some tolerance for it can reduce the number of unnecessary immediate acks substantially.  In order for this to not delay loss detection in some cases, the ack_delay field needs to be no larger than the time threshold for loss detection, which could be a limitation depending upon min_ack_delay, but I would typically expect to be fine.\r\n\r\nThe field could also be used for other use cases where packets aren't always sent in order, but that doesn't need to be explained in this draft.\r\n\r\nFor implementation, on every ack-eliciting packet:\r\n- If it's smaller than the largest acked in the last sent ack frame, send an immediate ACK because it fills a hole.\r\n- If it's larger than the last sent largest acked, only send an immediate ACK if there are missing packets greater than the last sent largest acked that are at least packet_threshold away from the current largest received packet.\r\n\r\nThis speeds up loss detection very slightly vs the core transport draft if the packet reordering threshold isn't an odd number, because the ACK is sent exactly when the sender will be able to use it to declare a loss.",
      "createdAt": "2020-04-18T20:24:57Z",
      "updatedAt": "2021-09-10T16:26:52Z",
      "closedAt": "2021-09-10T16:26:52Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "Thank you for opening the issue, I think this is the correct direction.\r\n\r\nHaving a way to specify a threshold is nothing but improvement from just having a boolean. I do not think there is a reason to object against changing the field to a threshold, based on the assumption that there is a use-case (as you describe).\r\n\r\nTo be clear, I am not excited about using reorder threshold for incuding ACKs when sending PTOs, because skipping _N_ is uglier than skipping 1, considering the fact that N (i.e. the threshold) might or not have been delivered to the peer. But that's a complaint against reusing this mechanism for inducing ACKs, and not an argument against changing the boolean flag to a threshold.",
          "createdAt": "2020-04-21T23:15:10Z",
          "updatedAt": "2020-04-21T23:15:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your thoughts and support @kazuho \r\n\r\nI agree that this is not an ideal fix for #34 and we may want to do more than this.",
          "createdAt": "2020-04-22T18:57:01Z",
          "updatedAt": "2020-04-22T18:57:01Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that an explicit threshold is strictly better than a boolean. The only problem is one of naming, where we now have two things that are arguably thresholds, where only one is titled as such (\"Packet Loss Threshold\" and \"Packet Tolerance\" )\ud83d\ude42 , but that's a bikeshed for #27.\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-29T16:35:17Z",
          "updatedAt": "2020-04-29T16:35:17Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is probably fine. This does put a larger burden on the receiver (a sender can simply set the variable to 0), but as I noted in [this comment](https://github.com/janaiyengar/ack-frequency/issues/18#issuecomment-578361546) on #18, the receiver can be reasonably simple too.\r\n\r\nI agree that it doesn't seem great though to solve this particular problem... in addition to requiring skipping N packets at the sender, it also means that when wanting an immediate ACK, a sender that would otherwise use 0 (ignore order) will now have to send two ACK_FREQUENCY frames: one to elicit the immediate ACK, and another later to set the ignore order back again. I'll think about this a bit more.",
          "createdAt": "2020-05-01T23:19:45Z",
          "updatedAt": "2020-05-01T23:19:45Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "How about if we simply say that the receiver always ACKs PINGs immediately? Does that solve the immediate ACK on PTO problem?",
          "createdAt": "2020-05-01T23:20:47Z",
          "updatedAt": "2020-05-01T23:20:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "ACKing PINGs immediately seems sensible and this question has come up before(I believe Igor raised it).  At the moment, PINGs exist to elicit an ACK and I don't think they have any other purpose?  There may need to be some rate-limit on immediate ACKs(ie: ACK within kGranularity rather than 'immediately'), but I think we have text that indicates waiting for kGranularity still counts as 'immediate'.\r\n\r\nChanging the response to PING would be a change to the core spec, so I'd suggest you create an issue immediately if we're going to do that.  In an ideal world, it wouldn't consume a byte, since that can make retransmission logic more complex(ie: do I include a PING with my PTO and remove a byte of payload or just send the full payload).  We have 2 unused bits in the header, so we could use one of those if we wanted.  That could be an extension, though it'd end up competing with the loss bits.\r\n\r\nBut this entire comment relates to #34 more than this issue.",
          "createdAt": "2020-05-02T00:58:08Z",
          "updatedAt": "2020-05-02T00:58:08Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> Changing the response to PING would be a change to the core spec\r\n\r\nCan't we simply limit this change to PING to when this extension is negotiated?",
          "createdAt": "2020-08-07T12:23:13Z",
          "updatedAt": "2020-08-07T12:23:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "As you might be able to tell from the discussion on the pull request, I've spent a little time working on this.  I struggled to understand this proposal, because the way it is framed is confusing.  I believe that there is a much simpler way of describing and implementing this than is in the current draft (and the proposed change).\r\n\r\nThe current strategy has you immediately ACK for any Initial or Handshake packet, or any packet numbered lower than the largest acknowledged.  (You might also add a packet containing PING, which is reasonable.)  The draft should put those universal conditions for an immediate ACK in a separate section.  Right now, this is not very clear in the text.\r\n\r\nThen there are those packets that arrive after largest acknowledged.  The draft before this change covers packets that arrive perfectly in sequence.  For those, there are a certain number that arrive that don't get acknowledged.  If you get more than that, then you acknowledge immediately.  This is currently phrased differently, in that you acknowledge when you receive N.  \r\n\r\nThis issue proposes to cover the case where the packets you receive after largest acknowledged are NOT contiguous.  Phrased in that way, the number is the same as the packet threshold, but it only applies after there is a gap detected.\r\n\r\nThat leaves you with:\r\n\r\n![Immediate ACK conditions](https://user-images.githubusercontent.com/67641/89747912-38f2a680-db04-11ea-9d7d-430556a8933a.png)\r\n\r\nThat is, there is a window in which packets can arrive without generating an immediate acknowledgment.  I've found that thinking in those terms simplifies this a lot.\r\n\r\nWith this picture in mind, the special 0 value that Ian's pull request uses to disable the loss threshold isn't necessary.  You can disable the special loss threshold by setting that value to be the same as the packet threshold.  You might have to prohibit the loss threshold from exceeding the packet threshold just to avoid silly conditions where a gap causes more delays, but the receiver could just clamp the value.\r\n\r\nI am going to suggest that this be changed to the number of unacknowledged, contiguous packets so that you can remove 0 as an invalid value.  That is, of course, orthogonal; you can always add one, but you can see that this is not necessary.  As you can see from the diagram, if you want an immediate ACK always, it is easier to think of the window being 0 width than it is to think about the packet that you received.\r\n\r\nBTW, you can also think about the time component in the same way: there is a period of time during which you don't generate an immediate acknowledgment.  That isn't perfect, because you start that period when the first packet arrives, but it's not a *bad* fit.",
          "createdAt": "2020-08-10T02:35:17Z",
          "updatedAt": "2020-08-10T02:35:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "One thing to note about the above is that you need to skip all non-ack-eliciting packets that appear immediately after the largest acknowledged packet.  Our stack doesn't individually track whether a received packet is ack-eliciting or not, so our logic isn't perfect in that regard.  I believe you get close though if you increase \"largest acknowledged\" by one every time the next packet arrives and it isn't ack-eliciting.\r\n\r\nThen the logic is fairly simple:\r\n\r\n```python\r\n# def on_received(pn):\r\nranges.add(pn) # Track receipt.\r\n\r\nif space != ApplicationData:\r\n    immediate_ack = true\r\nelse if pn == ranges.largest.largest:\r\n    # This determines whether there is a gap in the unacknowledged packets.\r\n    if largest_acknowledged < ranges.largest.smallest:\r\n        threshold = loss_threshold\r\n    else:\r\n        threshold = packet_threshold\r\n    immediate_ack = pn > largest_acknowledged + threshold\r\nelse if pn < largest_acknowledged:\r\n    immediate_ack = true\r\nelse:\r\n    immediate_ack = false\r\n\r\nif ack_eliciting:\r\n    if immediate_ack:\r\n        send_ack(now)\r\n    else:\r\n        schedule_ack(now + ack_delay)\r\nelse if pn == largest_acknowledged + 1:\r\n    # Disregard this packet for later packet/loss threshold calculations.\r\n    largest_acknowledged = pn\r\n```",
          "createdAt": "2020-08-10T09:56:46Z",
          "updatedAt": "2020-08-10T09:57:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson I think that _almost_ works, but I am not sure if it's sufficient. It seems that the approach does not handle reordered packets that carry packet numbers below largest acked, and I think that might be a problem.\r\n\r\nLet's consider the following example. There are two paths from the server, with a difference of 10ms. The server sends a packet every millisecond. Odd-numbered packets are transferred on the faster path, even-numbered ones on the slower path. \"Packet Tolerance\" is set to 25 packets (1/8th of RTT).\r\n\r\n```\r\n   +------ 100ms ------+\r\n   v                   |\r\nserver --> 100ms --> client\r\n       --> 110ms -->\r\n```\r\n\r\nThe client will receive packets in the order of something like: 11, 2, 13, 4, 15, 6, 17, 8, 19, 10, 21, 12, 23, 14, 25, 16, 27, 18, 29, 20 ...\r\n\r\nWhat we want to achieve is:\r\n* When the reordering threshold is small (e.g., 5), this pattern should elicit one ack every 2 packets.\r\n* When the reordering threshold is above the reorder (e.g., 12), this pattern should elicit one ack every 25 packets.\r\n\r\nGoing back to the algorithm proposed in https://github.com/janaiyengar/ack-frequency/issues/35#issuecomment-671265305. Let's say that the client has sent an ack when it received 15. It will then go on to send acks when it receives packet 6, 8, 10, 12, 14, because the received packet number is below largest acked.\r\n\r\nIn this example, the proposed approach will emit 6 acks per 35 incoming packets, whereas what we want to see is 1 ack per 25 incoming packets.",
          "createdAt": "2020-08-12T07:50:50Z",
          "updatedAt": "2020-08-12T07:50:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "So I worked through that and concluded that in cases of severe reordering you do get a burst of acknowledgments.  And if you have consistent reordering that happens a lot.\r\n\r\nIn your case, at least at the beginning, you will accumulate packets up to some number before you hit the reordering threshold and send an immediate ACK.  A reordering threshold less than 10 results in an ACK for every packet, but that's the intent, is it not?\r\n\r\nAs for the 6, 10, 10, 12, 14 being immediately acknowledged, this is based on this text in Ian's proposed resolution to this issue:\r\n\r\n> [...], implementations MUST still immediately acknowledge any received packets with packet numbers smaller than the largest 'Largest Acked' value previously sent in an ACK frame.\r\n\r\nI just accepted this premise as valid, but I see that it might not be.  In this example, it doesn't matter what is acknowledged, the next packet (and every other) will result in an immediate ACK.\r\n\r\nAnother scenario, perhaps a more realistic scenario one, is the one where a single packet (a small packet at the tail of a sequence of larger packets) is significantly reordered.  If you have 40 packets in flight and the last one jumps ahead of 23 of them, then this algorithm might be OK or it might not.  If it sees that packet 40 is preceded by 23 gaps, and it has acknowledged something past packet 15, then it will let the gap fill in if the loss threshold is 22 or 23.  If it acknowledged anything less than 15, it will immediately acknowledge 40 and then generate an immediate ACK for every packet that arrives as the gap is filled.  The huge variation between those cases is a little worrying.\r\n\r\nIf instead we count unacknowledged, ack-eliciting packets then we get something different.  You count each arriving ack-eliciting packet toward both thresholds if (? algorithm), but only toward the packet threshold if there is not.  We don't care about the largest acknowledged, just newly arriving packets.\r\n\r\nThe algorithm that I might use for that might look like:\r\n\r\n```python\r\n# def on_received(pn):\r\nexpected = ranges.largest.largest + 1\r\nranges.add(pn) # Track receipt.\r\n\r\n# Assuming that the packet was ack-eliciting...\r\nif space != ApplicationData:\r\n    immediate_ack = true\r\nelse:\r\n    out_of_order ||= pn != expected:\r\n    unacknowledged += 1\r\n    if out_of_order:\r\n        immediate_ack = unacknowledged > loss_threshold\r\n    else:\r\n        immediate_ack = unacknowledged > packet_threshold\r\n```\r\n\r\nThis doesn't consider the largest acknowledged at all.\r\n\r\nDoes that sound better?",
          "createdAt": "2020-08-12T09:45:42Z",
          "updatedAt": "2020-08-12T09:45:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson Thank you for the response.\r\n\r\nI think it might be better to take a step back and discuss what we want to achieve, before discussing how things can be implemented.\r\n\r\n> In your case, at least at the beginning, you will accumulate packets up to some number before you hit the reordering threshold and send an immediate ACK. A reordering threshold less than 10 results in an ACK for every packet, but that's the intent, is it not?\r\n\r\nWe do not expect to see that. In our case (sending HTTP responses from different nodes within a server cluster), we would know when we would start sending from multiple nodes, and when we would stop doing so. Therefore, we can increase reordering threshold when we are about to enter that mode, reduce the threshold when we exit.\r\n\r\nConsider the case of sending two incremental responses from two nodes. Assuming that the prioritization logic would designate different QUIC streams for every packetiztaition opportunity, we will see the pattern that I used as the example; half of the packets (e.g., odd-numbered) sent from one cluster node arrive earlier (or later) than those sent from the other.\r\n\r\n> Another scenario, perhaps a more realistic scenario one, is the one where a single packet (a small packet at the tail of a sequence of larger packets) is significantly reordered.\r\n\r\nWe expect to see this pattern, when the coordinator node within the cluster sends ACKs, while all the ack-eliciting packets are sent by a different node.\r\n\r\nAt the moment, the draft has `ignore_order` bit, and it covers these use-cases fairly well. For us, setting the ignore bit and relying on packet threshold (which would be set to 1/8th of CWND) would work fine.\r\n\r\nAs stated in [my earlier comment](https://github.com/janaiyengar/ack-frequency/issues/35#issuecomment-617459893), my strong desire is that the switch from a boolean to an integer, assuming that would happen, would not cause regression regarding these use-cases.",
          "createdAt": "2020-08-12T10:38:24Z",
          "updatedAt": "2020-08-12T10:38:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "body": "Based on this feedback, I think that the simpler scheme this envisages is much better than what I earlier suggested.  So I am now of the opinion that this issue should be closed without changing the spec.",
          "createdAt": "2021-04-07T22:36:32Z",
          "updatedAt": "2021-04-07T22:36:32Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: We believe that there might be some non-zero performance benefits in doing packet_threshold, but there is clearly high cognitive complexity and therefore unknown issues. At this time, we believe that retaining ignore_order allows us to move forward, and if there is more information that shows the value of doing more, we will revisit this issue.\r\n\r\n(To be discussed at IETF.)",
          "createdAt": "2021-07-19T20:56:40Z",
          "updatedAt": "2021-07-19T20:56:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Until there's evidence this is valuable for performance, closing this.",
          "createdAt": "2021-09-10T16:26:52Z",
          "updatedAt": "2021-09-10T16:26:52Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2MTE0OTk3NzU=",
      "title": "Allow using kGranularity instead of max_ack_delay in PTO calculation",
      "url": "https://github.com/quicwg/ack-frequency/issues/37",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "With this extension, an immediate ACK is expected if more than the \"Packet Tolerance\" ack-eliciting packets are outstanding.  Given that, it may be a worthwhile optimization to allow the max_ack_delay to not be included in the PTO computation in some cases.  If we're not going to allow that, I think we should explain why.\r\n\r\nhttps://github.com/janaiyengar/ack-frequency/blob/master/draft-iyengar-quic-delayed-ack.md#computation-of-probe-timeout-period\r\n\r\nThis split off #34, but I think the question of whether max_ack_delay always needs to be included in PTO should be separate from whether QUIC would benefit from an ACK-pull mechanism of some sort.  That being said, if a mechanism did exist, we add details about when ACK-pull allowed max_ack_delay to not be included.",
      "createdAt": "2020-05-03T20:26:32Z",
      "updatedAt": "2021-09-10T07:15:35Z",
      "closedAt": "2021-09-10T07:15:35Z",
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a clever optimization, I agree it's worth some text.",
          "createdAt": "2021-07-19T20:59:08Z",
          "updatedAt": "2021-07-19T20:59:08Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU2NDEwMjc5OTc=",
      "title": "What about ack decimation?",
      "url": "https://github.com/quicwg/ack-frequency/issues/38",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Chrome has [some logic](https://source.chromium.org/chromium/chromium/src/+/master:net/third_party/quiche/src/quic/core/quic_received_packet_manager.cc;l=284-287) to delay sending of an immediate acknowledgement for reordered packets. This reduces the number of ACKs sent, since, if I remember @ianswett's presentation in mapgr correctly, most of the packet reorderings are just one packet number apart from each other.\r\n\r\nDo we need something like this?",
      "createdAt": "2020-06-18T08:49:07Z",
      "updatedAt": "2021-09-10T16:25:52Z",
      "closedAt": "2021-09-10T16:25:52Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This didn't end up being that useful in practice(application metrics were slightly worse), so it's in the process of being removed.\r\n\r\nI think it turns out sending an extra ACK for an occasional twiddle just isn't that costly.",
          "createdAt": "2020-07-27T19:33:23Z",
          "updatedAt": "2020-07-27T19:33:23Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing editors' discussion: This is a variation on `ignore_order`, and the proposed resolution is similar to #35: go with simple `ignore_order` until we have new data/information.",
          "createdAt": "2021-07-19T21:07:17Z",
          "updatedAt": "2021-07-19T21:07:17Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU3MTUwOTAwMjk=",
      "title": "Specify whether storing min_ack_delay TP is mandatory",
      "url": "https://github.com/quicwg/ack-frequency/issues/40",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "The transport I-D 31 [states](https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-7.4.1):\r\n\r\n```\r\n   The definition of a new transport parameter (Section 7.4.2) MUST\r\n   specify whether storing the transport parameter for 0-RTT is\r\n   mandatory, optional, or prohibited.  A client need not store a\r\n   transport parameter it cannot process.\r\n```\r\n\r\nThis information is missing from [draft-iyengar-quic-delayed-ack-01](https://tools.ietf.org/html/draft-iyengar-quic-delayed-ack-01).",
      "createdAt": "2020-10-05T19:08:26Z",
      "updatedAt": "2021-09-10T16:24:45Z",
      "closedAt": "2021-09-10T16:24:45Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "FWIW, I tend to think that this issue is coupled with #22, and that endpoints do not need to, due to the reasons being explained on that issue.",
          "createdAt": "2020-11-03T02:16:17Z",
          "updatedAt": "2020-11-03T02:16:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #63",
          "createdAt": "2021-09-10T16:24:45Z",
          "updatedAt": "2021-09-10T16:24:45Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU3MzQ5MzIxNDY=",
      "title": "Directionality of the negotiation",
      "url": "https://github.com/quicwg/ack-frequency/issues/42",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To me it seems that the draft can be interpreted in the following two ways. It would be great if there was a clarification regarding which is correct:\r\n\r\n* `min_ack_delay` TP is a declaration that the endpoint will recognize ACK_FREQUENCY frames. The receiver of the TP can send ACK_FREQUENCY frames regardless of it sending `min_ack_delay` TP or not.\r\n* Use of delayed acks are negotiated by both endpoints sending `min_ack_delay` TP. ACK_FREQUENCY frames can be used only when the both endpoints send the TP.\r\n\r\nI assume that the intent to be the latter, but I'm not sure.",
      "createdAt": "2020-11-03T00:34:12Z",
      "updatedAt": "2021-04-19T18:37:46Z",
      "closedAt": "2021-04-19T18:37:46Z",
      "comments": [
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting, I actually interpreted it to be the former. I think it is reasonable for an implementation to accept ACK_FREQUENCY without having any intention of sending them itself. I.e. I don't see any reason it has to be mutually negotiated. ",
          "createdAt": "2020-11-03T04:09:52Z",
          "updatedAt": "2020-11-03T04:09:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "I agree that it's totally fine to consider the use being allowed independently for each direction. Though, for the ease of testing, I might prefer the use being negotiated mutually. It's a bit complex to have two flags; one that emits the min_ack_delay TP and another that controls the recognition of that TP sent by the peer.\r\n\r\nEndpoints that are not interested in sending ACK_FREQUENCY frames can just send the min_ack_delay TP ~with the value set to max_ack_delay~.",
          "createdAt": "2020-11-03T04:37:50Z",
          "updatedAt": "2020-11-03T04:51:06Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "@mjoras -- that's not quite right. If this were unilateral, that would mean that an endpoint that _receives_ the TP would not need to advertise the TP. That's a bit confusing, since the endpoint that sends the TP intends to use the ACK_FREQUENCY frame, which it wouldn't then be able to do.\r\n\r\nThe most straightforward interpretation is the second one that @kazuho proposes.",
          "createdAt": "2020-11-06T03:44:11Z",
          "updatedAt": "2020-11-06T03:44:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "body": "> That's a bit confusing, since the endpoint that sends the TP intends to use the ACK_FREQUENCY frame, which it wouldn't then be able to do.\r\n\r\nI think it can be quite natural depending on how you see it. We can define the TP as a proclamation by an endpoint to respect ACK_FREQUENCY frames. I would also point out that most (maybe all) transport parameters are unilateral declarations of endpoint properties, rather than a negotiation.\r\n\r\nThat said, with either of the approaches, it is impossible for an endpoint to declare support for multiple versions. I'm not sure if that's required, but it might be necessary. If we want to support multiple versions, then, we can either:\r\n* Say that each endpoint unilaterally declares it's capabilities (or supported versions); then the peer chooses what to use and sends the chosen capability (or the version) using a frame, much like how ALPN is being selected.\r\n* Say that the support for delayed-ack is negotiated by both endpoints. Each endpoints send a list of supported versions, and we define a logic for choosing one from the lists provided by both endpoints.\r\n\r\nPersonally, I think I prefer the former, especially if we are to negotiate use of multiple extensions at once. But the necessity is still unclear.",
          "createdAt": "2020-11-07T08:28:59Z",
          "updatedAt": "2020-11-07T08:29:11Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think it can be quite natural depending on how you see it. We can define the TP as a proclamation by an endpoint to respect\r\n> ACK_FREQUENCY frames. I would also point out that most (maybe all) transport parameters are unilateral declarations of\r\n> endpoint properties, rather than a negotiation.\r\n\r\nAh. I clearly misread what @mjoras was saying.  Yeah, this does align with the rest of the TPs, and it also aligns well with the intent of this TP -- each endpoint has to declare that it will respect and act on an ACK_FREQUENCY frame when one is received.\r\n\r\nI like the unilateral declaration of capabilites. I don't think we will need to support multiple versions in the longer term, but it's worth supporting if it isn't difficult to do. And in this case, I think it naturally aligns well with the intent of the frame.\r\n",
          "createdAt": "2020-11-09T00:24:54Z",
          "updatedAt": "2020-11-09T00:24:54Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There's been no change on this in a while, so I'm planning to merge @nibanks PR soon unless someone speaks up.",
          "createdAt": "2021-04-15T16:24:50Z",
          "updatedAt": "2021-04-15T16:24:50Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU3ODMwOTkyMjM=",
      "title": "Does the maximum max_ack_delay value apply to \"Update Max Ack Delay\"?",
      "url": "https://github.com/quicwg/ack-frequency/issues/43",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "QUIC Transport specifies a maximum value of 2^14 ms (roughly 16s) for the `max_ack_delay` transport parameter. Does this limit apply to values sent in the `Update Max Ack Delay` field of the ACK_FREQUENCY frame, or is any value up to 2^62 microseconds allowed here?\r\nEither way, the draft might benefit from clarifying the rules here.",
      "createdAt": "2021-01-11T06:18:48Z",
      "updatedAt": "2021-07-31T01:15:51Z",
      "closedAt": "2021-07-31T01:15:51Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The editors do not have a strong opinion, and we currently say nothing about the limit being changed by this extension, so we're inclined to keep the limit as is and add some text clarifying that the extension doesn't change the limit.\r\n\r\nWe're open to arguments otherwise if people have them.",
          "createdAt": "2021-07-22T20:08:16Z",
          "updatedAt": "2021-07-22T20:08:33Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU3ODMxNDQ2MDc=",
      "title": "min_ack_delay allows encoding of values larger than the maximum max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/44",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "If I understand correctly, the maximum value of the `min_ack_delay` transport parameter is supposed to ensure that the value is smaller or equal than the `max_ack_delay` transport parameter.\r\n\r\nAccording to [QUIC-TRANSPORT Section 18.1](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#name-reserved-transport-paramete) the maximum value of `max_ack_delay` is `(2^14 - 1) ms = 16,383,000 \u03bcs`. However, the maximum value of `min_ack_delay` is `(2^24 - 1) \u03bcs = 16,777,215 \u03bcs`.",
      "createdAt": "2021-01-11T07:43:30Z",
      "updatedAt": "2021-07-31T01:15:51Z",
      "closedAt": "2021-07-31T01:15:51Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We're going to remove the 2^24 - 1 limit and just rely on the MUST that min_ack_delay can't be greater than max_ack_delay, which implies the 2^14-1 limit.",
          "createdAt": "2021-07-22T20:13:03Z",
          "updatedAt": "2021-07-22T20:13:03Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4MjAyNjgyMjU=",
      "title": "Maximum Values for Frame Fields",
      "url": "https://github.com/quicwg/ack-frequency/issues/45",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Does it make sense to specify any maximum values for any of the ACK frequency frame fields, such as for Packet Tolerance? Does a value of 4 billion make sense? Can I use a `uint8_t` in my implementation to store this locally? Is there any expectation around the sizes of these fields? If there is no explicit max, what if I implicitly apply one? I'm working on implementing this and I'm trying to figure out how small (byte size) I can make the variables I use to store the values on the connection.",
      "createdAt": "2021-03-02T18:19:48Z",
      "updatedAt": "2021-07-31T01:13:42Z",
      "closedAt": "2021-07-31T01:13:42Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Update Max Ack Delay will be limited by the Max Ack Delay limit once #57 lands.\r\n\r\nThat leaves Packet Tolerance, which I agree is reasonable to limit to a value smaller than 2^62-1 locally.\r\n\r\nWe could add a comment like \"Implementations that have a lower limit than 2^62-1 on the Packet Tolerance MUST set treat it as though the maximum supported Packet Tolerance value has been received.\"",
          "createdAt": "2021-07-22T20:31:57Z",
          "updatedAt": "2021-07-22T20:31:57Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Slight tweak: \"If an endpoint receives a Packet Tolerance value that is larger than the maximum value it can represent, the endpoint MUST use the largest representable maximum value instead.\"",
          "createdAt": "2021-07-22T20:35:51Z",
          "updatedAt": "2021-07-22T20:36:05Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4MjE1MDU0Mjc=",
      "title": "Use Same Units for min_ack_delay and max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/issues/46",
      "state": "CLOSED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Do we really need to allow for sub-millisecond min_ack_delays? IMO, it would simplify my code if both min and max had the same units of milliseconds. Just set the value to zero if you really want to allow that small of values and then cap it internally if you receive the frame.\r\n\r\nQuotes from the relevant texts:\r\n\r\n>    max_ack_delay (0x0b):  The maximum acknowledgment delay is an integer\r\n>       value indicating the maximum amount of time in milliseconds by\r\n>       which the endpoint will delay sending acknowledgments.\r\n\r\nand\r\n\r\n>    min_ack_delay (0xff02de1a):  A variable-length integer representing\r\n>       the minimum amount of time in microseconds by which the endpoint\r\n>       can delay an acknowledgement.",
      "createdAt": "2021-03-03T21:35:36Z",
      "updatedAt": "2021-03-08T19:06:18Z",
      "closedAt": "2021-03-08T19:06:18Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think microseconds are better for this draft, since one potential application is within datacenters, where sub-ms timers are not uncommon.\r\n\r\nAt some point, we actually discussed changing the core draft to be microseconds, but concluded that changing the core draft wasn't worthwhile given we already knew we'd have this draft coming with microsecond granularity.",
          "createdAt": "2021-03-04T01:25:58Z",
          "updatedAt": "2021-03-04T01:25:58Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "@ianswett at least for Windows, we can't achieve a timer granularity of less than a millisecond with any accuracy, and that only at the cost of changing the default (which can have significant power impacts) from 15.6 milliseconds; so any value less than 1 millisecond is generally unusable for Windows based solutions. I'm not saying we should do something just because that's what Windows can do, but it should be taken into account. How accurately can Linux achieve timers in a data center? Especially if it's on a VM? I'm not going to die on this hill (I already wrote the code) but it's not great code because of these differences.",
          "createdAt": "2021-03-04T01:36:17Z",
          "updatedAt": "2021-03-04T01:36:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "In Linux, high resolution timers are quite common, though certainly not universal, and even VMs running linux guests commonly have hrtimers.\r\n\r\nSpecifically, in Linux TCP pacing and SACK compression(https://lwn.net/Articles/755078/) use hrtimers.",
          "createdAt": "2021-03-04T14:04:56Z",
          "updatedAt": "2021-03-04T15:07:12Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. It would have been nice to have max_ack_delay be the same units then. Any idea why milliseconds was decided on for that instead of microseconds? I don't remember any particular discussion around this in the past.",
          "createdAt": "2021-03-08T18:35:27Z",
          "updatedAt": "2021-03-08T18:35:27Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/quicwg/base-drafts/issues/3363",
          "createdAt": "2021-03-08T19:00:45Z",
          "updatedAt": "2021-03-08T19:00:45Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "Ok. Thanks @ianswett. I'll close this for now then.",
          "createdAt": "2021-03-08T19:06:18Z",
          "updatedAt": "2021-03-08T19:06:18Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU4NTI0NTAwMzU=",
      "title": "CE marking should not always cause an immediate ACK",
      "url": "https://github.com/quicwg/ack-frequency/issues/48",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "From Mirja: \"For ECN, you don't need to send an immediate ACK for each CE. Immediate ACKs are most important when the codepoint switches to CE, but then, if multiple CEs in a row are received, you can bundle the ACK information. See also https://tools.ietf.org/html/draft-ietf-tcpm-accurate-ecn#section-3.2.2.5.1\r\n(Note that we are still working on that section for AccECN but I think any changes are only relevant for specifics of TCP)\"",
      "createdAt": "2021-04-07T14:09:29Z",
      "updatedAt": "2021-09-14T00:29:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "From editors' discussion: This text is the same as that in RFC9000 (https://quicwg.org/base-drafts/rfc9000.html#name-sending-ack-frames), and we don't believe we need to depart from existing text for CE-marked packets, since those are true congestion events, and we don't need to optimize for collapsing acks during congestion.",
          "createdAt": "2021-07-22T20:53:59Z",
          "updatedAt": "2021-07-22T20:53:59Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "body": "Insisting on feeding back an ACK whenever there's a CE will come back to haunt you. \r\n1. After the hundredth CE in a row, you'll probably start to realize that each CE is not a 'congestion event'. \r\n2. You need to make sure that this doesn't force the receiver to ACK every CE-marked ACK, which could lead to interminable ACK ping-pong.\r\n\r\nAdmittedly, the sender should be slowing down, so perhaps it's not so bad to ram the reverse path full of ACKs under 100% congestion in the forward path. But it's not necessary - you could potentially squash other traffic sharing the reverse path. Particularly not nice in the first RTT before the sender starts responding. \r\n\r\nInstead, a requirement like under the [AccECN link](https://datatracker.ietf.org/doc/html/draft-ietf-tcpm-accurate-ecn#section-3.2.2.5.1) that Mirja pointed to, where you ACK every 'n' CE marks in a row will be sufficient. And if the peers support ACK frequency control, you might want to say 'n' is the greater of a) whatever 'standard' value is set by the IETF and b) the current ACK frequency requested by the sender.\r\n\r\nFinally, note that the AccECN section linked above was massively changed between -14 (when Mirja pointed to it) and -15 (now). Nearly all of the changes would be relevant to QUIC too (except the stuff about DupACKs, I think). So it's worth reading it all again carefully.",
          "createdAt": "2021-09-11T11:56:08Z",
          "updatedAt": "2021-09-11T11:56:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the specific suggestion Bob, that's extremely helpful.\r\n\r\nI think there are four ways forward:\r\n1) Stick with the current text and deal with the performance hit when using non-classic ECN.\r\n2) Always do something along the lines AccECN is suggesting when ACK_FREQUENCY is negotiated, ie: Ack immediately when max(2, Ack-Eliciting Threshold) packets with CE marks are received.\r\n3) Change the ignore_order 'bool' to be an enum with 4 values that are a mix of Classic(RFC9000) and accurate ECN response to CE marks.\r\n4) Do something completely from RFC9000 or AccECN.  I'm not sure what would inform this, but maybe there are aspects of QUIC which means the ACK response should be different from TCP Accurate ECN.\r\n\r\nI favor 2 and wrote #68 to document that.  My personal opinion is that classic ECN is not able to perform as well as newer marking schemes and should be deprecated, so perpetuating it is actively harmful.",
          "createdAt": "2021-09-11T20:17:19Z",
          "updatedAt": "2021-09-12T13:17:32Z"
        },
        {
          "author": "bbriscoe",
          "authorAssociation": "NONE",
          "body": "The design is not (only) for 'non-classic ECN', it's for handling any severe reverse channel congestion.\r\n\r\nFor the avoidance of doubt, if @ianswett's #2 alternative is meant to be \"as Bob (AccECN) suggested\", a number of possibly important details are missing:\r\n\r\n- a) Immediately ACK the first transition from a non-CE packet to a CE data packet; and b) ACK every max(2, Ack-Eliciting Threshold) contiguous CE marked packets after that.\r\n- The choice of 'packet' (twice) or 'data packet' (once) in the above is deliberate\r\n\r\nI agree that ECN feedback in RFC3168 should be deprecated (which is why I didn't object when it was proposed that AccECN should move from experimental to stds track update to 3168).\r\n\r\n\r\n",
          "createdAt": "2021-09-12T15:46:24Z",
          "updatedAt": "2021-09-12T15:46:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR includes the 'Immediately ACK the first transition from non-CE to CE.  PTAL and see if the text looks correct.",
          "createdAt": "2021-09-12T20:55:48Z",
          "updatedAt": "2021-09-12T20:55:48Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "After further thinking, I'm wondering if we should have multiple modes that are indicated by bits in the 'Ignore Order' bytes.\r\n\r\nSpecifically:\r\n- 0 is rfc9000 behavior.\r\n   -  Conveniently, this means clients sending Ignore Order values of 0 or 1 will see no change in behavior.\r\n- 1 is Ignore CE when choosing how frequently to acknowledge packets.\r\n  - This would likely be the best option for ECN algorithms where close to 50% of packets are marked.\r\n- 2 is accurate ECN, which is the current PR.",
          "createdAt": "2021-09-14T00:29:33Z",
          "updatedAt": "2021-09-14T00:29:33Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU4NTI4ODI3OTU=",
      "title": "Off-by-one in packet tolerance",
      "url": "https://github.com/quicwg/ack-frequency/issues/49",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "The definition that I use internally is \"the number of packets you can receive without sending an immediate acknowledgment\".  This is different than saying \"please acknowledge every N packets\".\r\n\r\nThe main benefit of this definition is that there are no invalid values for the number.  I recommend making this adjustment in the frame definition: it will be more efficient (by a tiny amount), but it also removes the need to validate the value.",
      "createdAt": "2021-04-07T22:39:24Z",
      "updatedAt": "2021-09-10T00:24:46Z",
      "closedAt": "2021-09-10T00:24:46Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a good change, it's just a matter of writing the text.",
          "createdAt": "2021-07-22T20:35:53Z",
          "updatedAt": "2021-07-22T20:35:53Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU5MjM5Nzg5NDQ=",
      "title": "Asymmetric paths are also impacted by packet rate",
      "url": "https://github.com/quicwg/ack-frequency/issues/51",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It's also true that for many RF media, the performance of the forward path can be impacted by the **rate** of acknowledgment packets when the link bandwidth is shared.\r\n\r\n",
      "createdAt": "2021-06-17T14:16:06Z",
      "updatedAt": "2021-07-22T20:36:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU5Mzg3OTE1MTk=",
      "title": "Could we construct an example of use?",
      "url": "https://github.com/quicwg/ack-frequency/issues/53",
      "state": "OPEN",
      "author": "gorryfair",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There's a concrete example of one way you can arrange ACKs that has benefit in:\r\nhttps://datatracker.ietf.org/doc/draft-fairhurst-quic-ack-scaling/\r\nThis likely helps in many common scenarios.\r\nWe could make a pull-request based on summarising some of this into an annexe?\r\n",
      "createdAt": "2021-07-07T11:29:09Z",
      "updatedAt": "2021-07-27T15:53:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Gorry -- can you point to the concrete example in the draft? I couldn't find it.\r\n\r\nGenerally, I'd prefer not to spend a lot more text in the draft motivating its value; I think we've got enough in Section 2 already. ",
          "createdAt": "2021-07-22T21:01:04Z",
          "updatedAt": "2021-07-22T21:01:04Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "What I was hoping for was something that unpicks a little how an ACK Ratio of (say) 10 (8 if we prefer, ?) impacts the traffic. I don't see the draft body needing to specify numbers, but I know there is experience by some implementations with this approach, so a short (<1 page) explanation might be good guidance for anyone who has not worked out something better ... but I'd prefer it to be in an annexe, because such things can, and will, change as well as new CCs emerging that can have new requirements, etc.",
          "createdAt": "2021-07-27T15:53:47Z",
          "updatedAt": "2021-07-27T15:53:47Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU5NTM4MzEyNjg=",
      "title": "Response to reordering, what is reordering?",
      "url": "https://github.com/quicwg/ack-frequency/issues/62",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "When reviewing the draft I got caught on this part:\r\n\r\nAs specified in Section 13.2.1 of [QUIC-TRANSPORT], endpoints are expected to send an acknowledgement immediately on receiving a reordered ack-eliciting packet. This extension modifies this behavior.\r\n\r\nThere is an issue here in how this draft uses \"reordering\". Section 13.2.1 of RFC 9000 does say that ACKs should be sent immediately if:\r\n\r\n\"In order to assist loss detection at the sender, an endpoint SHOULD generate and send an ACK frame without delay when it receives an ack-eliciting packet either:\r\n\r\n- when the received packet has a packet number less than another ack-eliciting packet that has been received, or\r\n\r\n- when the packet has a packet number larger than the highest-numbered ack-eliciting packet that has been received and there are missing packets between that packet and this packet.\"\r\n\r\nAlthough the first bullet clearly is reordering, the second could be caused by three different mechanisms: Reordering of packets, loss of packets, or sender intentional gap (as discussed in #34)\r\nThus, I think this section needs to be clear if actually means both of the above bullets for when to send ACK or only one of them? \r\n",
      "createdAt": "2021-07-27T12:28:01Z",
      "updatedAt": "2021-07-27T21:02:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Magnus, the intent was to follow the RFC9000 definition, so I'll write a PR to clarify that was the intent.",
          "createdAt": "2021-07-27T20:49:50Z",
          "updatedAt": "2021-07-27T20:49:50Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU5OTEwODc4NTc=",
      "title": "Should we add a DELAY_ACK frame?",
      "url": "https://github.com/quicwg/ack-frequency/issues/65",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "As a natural opposite to #34 adding an IMMEDIATE_ACK frame, I want to know if the WG thinks there's sufficient interest in this.  I know there are use cases like WebRTC where fine control over the ACKs is desirable.\r\n\r\n@nibanks may be interested in this, since a similar topic came up on https://github.com/quicwg/datagram/issues/42",
      "createdAt": "2021-09-08T12:32:51Z",
      "updatedAt": "2021-09-14T00:39:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I would be fine with using this mechanism to solve the issues described in quicwg/datagram#42.",
          "createdAt": "2021-09-10T12:01:55Z",
          "updatedAt": "2021-09-10T12:01:55Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this would be very useful to have. Specifically we have seen interest similar to what @nibanks has mentioned -- existing applications that have their own \"application layer\" (partial) reliability and congestion control but want to leverage QUIC as a connection-oriented way to send encrypted datagrams. Having more explicit control over not-ACKing would certainly help some of these usecases.\r\n\r\nWhile I would rather people design protocols around QUIC application data semantics in full (streams and DATAGRAMs and some as-yet-undesigned partial reliability feature) rather than just plumbing an existing protocol over QUIC DATAGRAMs, I think that having a facility to get more applications running over QUIC is very useful.",
          "createdAt": "2021-09-10T17:13:13Z",
          "updatedAt": "2021-09-10T17:13:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Just say NO! Really, this kind of experiment goes in the way of progressing the delayed ACK proper. We have tons of experience with delayed acks, and we understand exactly what it does. Why would we create this additional mechanism, with unproven effects?",
          "createdAt": "2021-09-13T00:20:40Z",
          "updatedAt": "2021-09-13T00:20:40Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "So, I think this naturally leads to the question of how long an ACK delay is actually acceptable for coexistence with other Internet use. Delayed ACKs our tens of packets are likely OK.  I'll argue that \"infinite\" delay (No ACK) it is not a great place to dig into. I suggest we should instead be restricting this to a few RTTs... (10's? 100s of packets).   I'd argue that for some form of reactive congestion control, feedback at least every few RTTs is necessary - this could even be a form of slower-reacting circuit-breaker, with the upper layers formally providing the responsive control to incipient ingestion.\r\n",
          "createdAt": "2021-09-13T11:22:55Z",
          "updatedAt": "2021-09-13T11:22:55Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "body": "I'm in agreement with @mjoras that a change like this would better be aligned with the application data semantics, unreliable datagrams in this case. As I indicated in https://github.com/quicwg/datagram/issues/42#issuecomment-912513452, there are several reasons an application protocol would want a reduction in (not complete elimination of) generated ACKs when using unreliable datagrams. There might be additional uses, generally, for delaying ACKs, but the reasoning around it is more complicated for reliable data. For the unreliable support, I can write that up in a new extension draft (if that is the general WG consensus).",
          "createdAt": "2021-09-13T12:16:00Z",
          "updatedAt": "2021-09-13T12:16:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea of this extending the ACK timeout, but not removing it completely is interesting.\r\n\r\nAn alternative design would be a DELAY_ACK frame which ensured a packet doesn't elicit an immediate ACK, but would still arm the timer for the delayed ACK alarm.",
          "createdAt": "2021-09-13T13:31:24Z",
          "updatedAt": "2021-09-13T13:31:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "Given the swathe of needs and possible options, I currently think there's going to need to be some more exploration of this space with some more substantial write ups.",
          "createdAt": "2021-09-13T13:47:17Z",
          "updatedAt": "2021-09-13T13:47:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just say NO! Really, this kind of experiment goes in the way of progressing the delayed ACK proper. We have tons of experience with delayed acks, and we understand exactly what it does. Why would we create this additional mechanism, with unproven effects?\r\n\r\nWe already have this ACK issue with PADDING only packets, which count towards bytes in flight, but are not ack-eliciting.  That design choice always terrified me.  I would have been much more comfortable with something like the DELAY_ACK design I proposed just above, which would ensure you eventually get an ACK for in-flight packets.",
          "createdAt": "2021-09-13T13:52:40Z",
          "updatedAt": "2021-09-13T13:52:58Z"
        },
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "As a mechanism, we should not use a frame to signal how a different frame should be interpreted. QUIC's design generally assumes that a sender does not control how frames are packetized, and this runs afoul of that unstated assumption.\r\n\r\nSpecifying the mechanism is easy, but I don't think this is quite as straightforward to reason about, at least in the context of the ack frequency draft. Broadly, this is not about controlling ack frequency, it's about disabling acks, or partially disabling acks, which makes it harder to reason about.\r\n\r\nLet's not do this here; as @LPardue notes, this has to become a larger conversation.",
          "createdAt": "2021-09-13T18:55:55Z",
          "updatedAt": "2021-09-13T18:55:55Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Given the pushback against my initial attempt, I'm pivoting to the DELAY_ACK frame.\r\n\r\nI'd actually like the negotiation of this extension to indicate the delayed ack behavior applies to PADDING only and PADDING+ACK packets as well, since I think those can be a bit of a footgun, but I'd like to see what people think of the DELAY_ACK frame before writing that text.",
          "createdAt": "2021-09-14T00:39:06Z",
          "updatedAt": "2021-09-14T00:39:06Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU5OTEyODc3NDY=",
      "title": "Change diagrams to use the notation in QUIC transport",
      "url": "https://github.com/quicwg/ack-frequency/issues/66",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "editorial",
        "needs-pr"
      ],
      "body": "They currently use ascii art.\r\n\r\nWill write this up once #64 is merged.",
      "createdAt": "2021-09-08T15:50:00Z",
      "updatedAt": "2021-09-08T16:10:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "sgtm, thanks!",
          "createdAt": "2021-09-08T16:10:33Z",
          "updatedAt": "2021-09-08T16:10:33Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzAyMzgx",
      "title": "Change Time Tolerance to Update Max Ack Delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/4",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes a few things:\r\n- Introduces a `min_ack_delay` TP for negotiating extension use\r\n- Changes `Time Tolerance` to `Update Max Ack Delay`\r\n- Makes the fields required\r\n- Specifies invalid values\r\n\r\nCloses #2.",
      "createdAt": "2020-01-17T20:15:30Z",
      "updatedAt": "2020-01-17T20:29:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "e95015dedcd85f71f3109160323aac0713023629",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/update-mad",
      "headRefOid": "65b71253ca21f0a95ad47240f717928c6e30a27a",
      "closedAt": "2020-01-17T20:29:05Z",
      "mergedAt": "2020-01-17T20:29:05Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "960e862fb19ca11f2285121b32270db46c139103"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm merging this, let's address issues in later PRs.",
          "createdAt": "2020-01-17T20:29:00Z",
          "updatedAt": "2020-01-17T20:29:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzM1NDkz",
      "title": "Add section on PTO computation with updated max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/7",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #1.",
      "createdAt": "2020-01-17T21:58:26Z",
      "updatedAt": "2020-01-17T21:59:36Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "960e862fb19ca11f2285121b32270db46c139103",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/pto",
      "headRefOid": "11fbdcd13c2250094e7216576c9d032709f0d0ee",
      "closedAt": "2020-01-17T21:59:36Z",
      "mergedAt": "2020-01-17T21:59:36Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "fc3eb17d4cf79f371ec138c26371e78ecc4d9b8b"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T21:59:30Z",
          "updatedAt": "2020-01-17T21:59:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzQ4NTYy",
      "title": "Add sequence number to frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/8",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #5.",
      "createdAt": "2020-01-17T22:46:39Z",
      "updatedAt": "2020-01-17T22:47:58Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "fc3eb17d4cf79f371ec138c26371e78ecc4d9b8b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/seqnum",
      "headRefOid": "6529108ccdbcec4f86ee9e6340124f0df66c3e59",
      "closedAt": "2020-01-17T22:47:58Z",
      "mergedAt": "2020-01-17T22:47:58Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "0b23026b4f9760a2ab0325dcef702770cbaee3ed"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T22:47:52Z",
          "updatedAt": "2020-01-17T22:47:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzUyMTkw",
      "title": "Handle initial conditions",
      "url": "https://github.com/quicwg/ack-frequency/pull/9",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and some editorializing.",
      "createdAt": "2020-01-17T23:02:08Z",
      "updatedAt": "2020-01-17T23:02:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0b23026b4f9760a2ab0325dcef702770cbaee3ed",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/initial",
      "headRefOid": "bf23ce91fd410dcef64ff53b4e561828469cf795",
      "closedAt": "2020-01-17T23:02:30Z",
      "mergedAt": "2020-01-17T23:02:30Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "254044e375d9517b107a2d789534d466b344caa4"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-17T23:02:21Z",
          "updatedAt": "2020-01-17T23:02:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzYzOTcy",
      "title": "Add reordering tolerance",
      "url": "https://github.com/quicwg/ack-frequency/pull/10",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #6.",
      "createdAt": "2020-01-18T00:00:59Z",
      "updatedAt": "2020-01-18T00:01:17Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "254044e375d9517b107a2d789534d466b344caa4",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/reordering",
      "headRefOid": "e6dbc9a96c2f02d6556e205c044515b16aa678a3",
      "closedAt": "2020-01-18T00:01:17Z",
      "mergedAt": "2020-01-18T00:01:16Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "06792883fc189e7296ea0fcf48e96bdd9b127e4a"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "merging.",
          "createdAt": "2020-01-18T00:01:11Z",
          "updatedAt": "2020-01-18T00:01:11Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0MzY5Nzk4",
      "title": "Add references, add Frame Type field to ACK-FREQUENCY frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/11",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-01-18T00:33:57Z",
      "updatedAt": "2020-01-18T00:48:03Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "3a7ca17cd9c65cf3073ee63d991374318e985659",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/refs",
      "headRefOid": "d1677752b7ed819995d6ced4b4c7a6ed0f64beaa",
      "closedAt": "2020-01-18T00:48:03Z",
      "mergedAt": "2020-01-18T00:48:03Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "ee639b160220d60b87fe03689a459049247b7d02"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1MDYyNjEy",
      "title": "Editorial comments",
      "url": "https://github.com/quicwg/ack-frequency/pull/12",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Plus fixing one spot where it said 2^14, but I think it should have been 2^24",
      "createdAt": "2020-01-21T02:03:39Z",
      "updatedAt": "2020-01-21T18:41:05Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0402c2a1f495dae0a97a19a9fbfb11bc9afcff0c",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial",
      "headRefOid": "8f28d22bee0aaccd82323410ea50854309445a24",
      "closedAt": "2020-01-21T18:41:05Z",
      "mergedAt": "2020-01-21T18:41:05Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "c45b03bbe836e6321f12a0373544b247c117ac9b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTAzODQw",
          "commit": {
            "abbreviatedOid": "8f28d22"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T18:40:59Z",
          "updatedAt": "2020-01-21T18:40:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDUwNzgy",
      "title": "A few more suggestions",
      "url": "https://github.com/quicwg/ack-frequency/pull/13",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changed the error code to FRAME_ENCODING_ERROR and removed a condition for update which I think may end up causing correctness issues.",
      "createdAt": "2020-01-21T18:35:52Z",
      "updatedAt": "2020-01-21T20:21:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0402c2a1f495dae0a97a19a9fbfb11bc9afcff0c",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial2",
      "headRefOid": "8996a31f11771c95d07083b826703d9be5cfa8e1",
      "closedAt": "2020-01-21T20:21:30Z",
      "mergedAt": "2020-01-21T20:21:30Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "b78e2486498a51aacdb7b6681709f40eff40a157"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I removed the comment you thought was unnecessary, and we can discuss it and any other changes to the section separately.",
          "createdAt": "2020-01-21T19:16:01Z",
          "updatedAt": "2020-01-21T19:16:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTA0Njk1",
          "commit": {
            "abbreviatedOid": "c09c66a"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T18:42:23Z",
          "updatedAt": "2020-01-21T18:50:10Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think this is necessary. The TP says nothing about ECN, and ECN says nothing about reordering.",
              "createdAt": "2020-01-21T18:42:23Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nfrom the most recent frame (frame with the highest sequence number) that was acknowledged.\r\n```",
              "createdAt": "2020-01-21T18:43:38Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nMUST use the maximum of the current value and all those in flight.  If there are\r\n```",
              "createdAt": "2020-01-21T18:44:00Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nACK-FREQUENCY frames in flight, then endpoints MUST use the `max_ack_delay` value\r\n```",
              "createdAt": "2020-01-21T18:48:42Z",
              "updatedAt": "2020-01-21T19:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTI1ODkx",
          "commit": {
            "abbreviatedOid": "8996a31"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T19:16:16Z",
          "updatedAt": "2020-01-21T19:16:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Removed.",
              "createdAt": "2020-01-21T19:16:16Z",
              "updatedAt": "2020-01-21T19:16:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTY1MjMx",
          "commit": {
            "abbreviatedOid": "8996a31"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:21:02Z",
          "updatedAt": "2020-01-21T20:21:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDUzNzE3",
      "title": "Editorial for undesirable consequence",
      "url": "https://github.com/quicwg/ack-frequency/pull/15",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Small readability tweaks",
      "createdAt": "2020-01-21T18:43:56Z",
      "updatedAt": "2020-01-21T20:22:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c45b03bbe836e6321f12a0373544b247c117ac9b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-editorial3",
      "headRefOid": "3fdeed2d74c382a3dc7c5b79297c0344028a422a",
      "closedAt": "2020-01-21T20:22:06Z",
      "mergedAt": "2020-01-21T20:22:06Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "7e2a9ce4a05201d4049794cc8ef1c75393658032"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTY1NzUw",
          "commit": {
            "abbreviatedOid": "3fdeed2"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:22:01Z",
          "updatedAt": "2020-01-21T20:22:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NDk3NzA5",
      "title": "Re-introduce text that was inadvertently removed",
      "url": "https://github.com/quicwg/ack-frequency/pull/16",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "and reflow some text.",
      "createdAt": "2020-01-21T20:31:17Z",
      "updatedAt": "2020-01-21T21:11:43Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "7e2a9ce4a05201d4049794cc8ef1c75393658032",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/fixtext",
      "headRefOid": "074576cbea9937431f380f30537f99bc7caebc1c",
      "closedAt": "2020-01-21T21:11:43Z",
      "mergedAt": "2020-01-21T21:11:43Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "c111991f576015fa11cb6c3e575c3a44412fdd0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTcyMjM2",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:33:25Z",
          "updatedAt": "2020-01-21T20:33:26Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I intentionally removed this, because I think it results in indeterminate behavior.  I think you either need to use packet number or sequence number, not both.",
              "createdAt": "2020-01-21T20:33:25Z",
              "updatedAt": "2020-01-21T20:56:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTc0MTEy",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:36:42Z",
          "updatedAt": "2020-01-21T20:36:43Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Ok, I misread this the first time as packet number for some reason.  I think we need to find a different term besides sequence number at some point.  Also, when is sequence number capitalized?  It seems other fields in the frame always are.",
              "createdAt": "2020-01-21T20:36:43Z",
              "updatedAt": "2020-01-21T20:56:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTc0MTYx",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T20:36:47Z",
          "updatedAt": "2020-01-21T20:36:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTg1ODEx",
          "commit": {
            "abbreviatedOid": "3715a8d"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T20:57:19Z",
          "updatedAt": "2020-01-21T20:57:20Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I had packet number earlier, but that was mistakenly left over. That should simply have been changed to sequence number, which is what this PR does.\r\n\r\nThe rule we've used is field names are capitalized, but when talking about the concept, it's not. (\"sequence number of the frame\" vs \"Sequence Number field in the frame\"). This is the same as how we did sequence number of NCID frames in the transport draft -- both cases are used in the same manner.",
              "createdAt": "2020-01-21T20:57:20Z",
              "updatedAt": "2020-01-21T20:57:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4Nzc2MzE3",
      "title": "Define codepoints for the transport param and frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/21",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also rename ACK-FREQUENCY to ACK_FREQUENCY to Fix #19 ",
      "createdAt": "2020-01-29T21:33:37Z",
      "updatedAt": "2020-01-31T02:49:44Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c111991f576015fa11cb6c3e575c3a44412fdd0e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-codepoints",
      "headRefOid": "51d932182544da7ccfc28b070c26ac451dccd2aa",
      "closedAt": "2020-01-31T02:49:44Z",
      "mergedAt": "2020-01-31T02:49:44Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "3b23c62e6bdb5f5a483a6dfeb73bd2e2030e0f67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4ODA1MjMx",
      "title": "Remove mention of slow start and hystart",
      "url": "https://github.com/quicwg/ack-frequency/pull/23",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #14  by removing references to slow start, hystart, and paced chirping.\r\n\r\nSlow start and BBR startup aren't quite the same as @mjoras mentioned, hystart isn't specified for QUIC, and paced chirping is not an IETF draft to my knowledge.",
      "createdAt": "2020-01-29T22:47:38Z",
      "updatedAt": "2020-01-31T02:50:22Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "c111991f576015fa11cb6c3e575c3a44412fdd0e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-remove-mentions",
      "headRefOid": "e8a98fb32d556a85410faeeb44ad1edd730a5143",
      "closedAt": "2020-01-31T02:50:22Z",
      "mergedAt": "2020-01-31T02:50:22Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "59bc418cfc1dc4ea350b50897b5d83af00d90568"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcwMDY0MDk1",
      "title": "Use frame instead of TP for reordering",
      "url": "https://github.com/quicwg/ack-frequency/pull/24",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #18.",
      "createdAt": "2020-02-02T22:31:55Z",
      "updatedAt": "2020-02-03T16:23:12Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "59bc418cfc1dc4ea350b50897b5d83af00d90568",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/ignore-order",
      "headRefOid": "9c70e5961d8abd1b4bdec754af1263cc44a6f2dd",
      "closedAt": "2020-02-03T16:23:11Z",
      "mergedAt": "2020-02-03T16:23:11Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "8c88e17ec7acdbc62a9cb26443db47139576a75f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxOTgxNjAy",
          "commit": {
            "abbreviatedOid": "4953c04"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I prefer \"Ingnore Reordering\" to \"Ignore Order\", though I admit the latter is slightly shorter.  One suggestion on making the text slightly more proscriptive.",
          "createdAt": "2020-02-03T00:40:28Z",
          "updatedAt": "2020-02-03T00:48:35Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "How about \", the receiver MUST only send an acknowledgement in response to receiving Packet Tolerance packets or after the updated max_ack_delay has passed, and MUST NOT send an immediate acknowledgement in response to out of order packets.\"",
              "createdAt": "2020-02-03T00:40:29Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nIgnore Reordering:\r\n```",
              "createdAt": "2020-02-03T00:45:11Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nrecent frame received from the peer has an `Ignore Reordering` value of `false`\r\n```",
              "createdAt": "2020-02-03T00:46:29Z",
              "updatedAt": "2020-02-03T16:22:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTAxNTcy",
          "commit": {
            "abbreviatedOid": "4953c04"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T09:04:00Z",
          "updatedAt": "2020-02-03T16:22:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This doesn't fit within that space, if you can find a better way to write this out, happy to do it.",
              "createdAt": "2020-02-03T09:04:00Z",
              "updatedAt": "2020-02-03T16:22:28Z"
            },
            {
              "originalPosition": 43,
              "body": "I'm taking the second half of this, the first half seems unnecessary",
              "createdAt": "2020-02-03T09:06:48Z",
              "updatedAt": "2020-02-03T16:22:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxNzQxMzQ4",
      "title": "0 is a valid min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/28",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #26",
      "createdAt": "2020-02-06T07:04:48Z",
      "updatedAt": "2020-02-06T07:11:19Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "8c88e17ec7acdbc62a9cb26443db47139576a75f",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-0-min-ack-delay",
      "headRefOid": "3f8b8e3b640413e8c47ce40437965653a7ef20db",
      "closedAt": "2020-02-06T07:11:18Z",
      "mergedAt": "2020-02-06T07:11:18Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "014ca67fd916f5a477fa6abb4a680ca86f51c56b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjM2NzUz",
          "commit": {
            "abbreviatedOid": "3f8b8e3"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-06T07:11:12Z",
          "updatedAt": "2020-02-06T07:11:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMzc5MTM3",
      "title": "Clarify when you might not retransmit",
      "url": "https://github.com/quicwg/ack-frequency/pull/29",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If there's a frame with a larger sequence number, there's no need to retransmit.",
      "createdAt": "2020-02-07T12:04:00Z",
      "updatedAt": "2020-02-27T23:27:06Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "014ca67fd916f5a477fa6abb4a680ca86f51c56b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-when-retransmit",
      "headRefOid": "b9b12132088c9e01acd43346565097b1389e0a2f",
      "closedAt": "2020-02-27T23:27:06Z",
      "mergedAt": "2020-02-27T23:27:06Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "0c59475c5eebf232679612a13fe8cc3b11731a5f"
      },
      "comments": [
        {
          "author": "rpaulo",
          "authorAssociation": "NONE",
          "body": "Thanks, looks good ;-)",
          "createdAt": "2020-02-08T10:58:03Z",
          "updatedAt": "2020-02-08T10:58:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDMzMTAw",
      "title": "Remove sections from motivations, add implementation considerations.",
      "url": "https://github.com/quicwg/ack-frequency/pull/31",
      "state": "MERGED",
      "author": "mjoras",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think the motivations section as-is is too long. It spends a lot of time\r\ntalking about what are effectively the tradeoffs. IMO the motivations section\r\nshould specify why it's useful to have the sender control the receiver's ACK\r\nfrequency, and then we can have a separate section for the tradeoffs.\r\n\r\nThis takes a stab at that section, lifting things from motivations and adding\r\nsome new text specifically addressing the nascent stages of a connection. \r\n\r\nI also made some editorial changes to the existing text.\r\n\r\nI am happy to add any additional considerations we think might need to be called out.\r\n\r\nThis attempts to resolve #17 ",
      "createdAt": "2020-02-13T18:53:22Z",
      "updatedAt": "2020-03-19T23:08:56Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "0c59475c5eebf232679612a13fe8cc3b11731a5f",
      "headRepository": "mjoras/ack-frequency",
      "headRefName": "master",
      "headRefOid": "2e3c981e2711c2f8da242937246c69db291c3031",
      "closedAt": "2020-03-19T23:08:56Z",
      "mergedAt": "2020-03-19T23:08:55Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "eb364241a0eef02207841a05a1e20ba9cd072af3"
      },
      "comments": [
        {
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the PR, @mjoras ! I like the new text you propose (I've proposed some changes), but I think you might be assuming that ACK_FREQUENCY is only used for delaying acks further. An important point that bears bringing out in the motivation is that a sender might want more frequent acks as well, for example during startup. That's worth capturing in the modified motivation section.",
          "createdAt": "2020-02-27T23:38:29Z",
          "updatedAt": "2020-02-27T23:38:29Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@mjoras this PR is almost done, any chance you can do another round of updates and we can get it in?",
          "createdAt": "2020-03-07T10:30:23Z",
          "updatedAt": "2020-03-07T10:30:23Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett sorry, I'll do some updates today.",
          "createdAt": "2020-03-16T17:03:21Z",
          "updatedAt": "2020-03-16T17:03:21Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett @janaiyengar I've updated the PR, I'll watch and iterate on any remaining feedback quickly this time.",
          "createdAt": "2020-03-16T17:21:32Z",
          "updatedAt": "2020-03-16T17:21:32Z"
        },
        {
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks @janaiyengar. Something about vim and the macbook pro keyboard apparently makes me incapable of spelling things properly. I want my desk keyboard back \ud83d\ude42 \r\n\r\n",
          "createdAt": "2020-03-19T20:01:18Z",
          "updatedAt": "2020-03-19T20:01:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTIzMDc3",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few comments and sugestions.",
          "createdAt": "2020-02-13T20:19:56Z",
          "updatedAt": "2020-02-13T20:25:28Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The frequency only matters if there are packets that arrive out of order, so it might be worth stating that?",
              "createdAt": "2020-02-13T20:19:56Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 47,
              "body": "This is a good use of the word Nascent, but I don't believe nascent is a commonly used word in the congestion control world, so I'd be inclined to call this section \"New Connections\"",
              "createdAt": "2020-02-13T20:21:32Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 57,
              "body": "This section seems a bit odd down here given this draft adds an explicit signal for the sender to tell the receiver what ACK strategy it wants.  The section could be re-written to advise the sender to delay sending the ACK_FREQUENCY frame while it's reliant upon frequent acknowledgements to quickly ramp up the congestion controller, and remove the part about how the receiver needs to be cautious about changing its strategy.",
              "createdAt": "2020-02-13T20:24:51Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTUyMzE1",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T21:09:15Z",
          "updatedAt": "2020-02-13T21:09:16Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I think I phrased this poorly. What I meant is that the _sender_ should be cautious in sending an ACK_FREQUENCY too early in the connection, as indeed the receiver is meant to be a passive actor in this decision making. I think we are on the same page here, I will rephrase.",
              "createdAt": "2020-02-13T21:09:15Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTUyNTkw",
          "commit": {
            "abbreviatedOid": "7ed0a51"
          },
          "author": "mjoras",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T21:09:44Z",
          "updatedAt": "2020-02-13T21:09:45Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Good point, I agree that's a good addition.",
              "createdAt": "2020-02-13T21:09:44Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDA1MjQw",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few more suggestions, but it looks good.",
          "createdAt": "2020-02-25T19:55:05Z",
          "updatedAt": "2020-02-25T20:04:52Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nstrategies and find those which best suit their congestion controllers, applications, and networks.\r\n```",
              "createdAt": "2020-02-25T19:55:05Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 45,
              "body": "How about \"Consequently, a receiver that sends acknowledgements less frequently force the sender to wait for the time threshold instead of the packet threshold.\"?  Are there other specific examples you have in mind?",
              "createdAt": "2020-02-25T19:57:32Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\ncontroller will quickly increase the amount of data in the network until it is\r\n```",
              "createdAt": "2020-02-25T20:04:04Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDcyNzYy",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "A few comments",
          "createdAt": "2020-02-27T23:31:44Z",
          "updatedAt": "2020-02-27T23:36:26Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@ianswett : I don't think that's accurate, since the ack may be received before the time threshold period passes. I  prefer Matt's wording, since it's not necessary to wade into details here.",
              "createdAt": "2020-02-27T23:31:44Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nMany congestion control algorithms have a special state for the beginning\r\n```",
              "createdAt": "2020-02-27T23:31:59Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 60,
              "body": "I agree with the premise, but not with the recommendation. A sender might want to ask the receiver to ack every packet during this phase, and that needs an ACK_FREQUENCY frame. I think what you want to say here is not to advise caution, but to note that a sender could use the frame to make the receiver ack more frequently during this phase.",
              "createdAt": "2020-02-27T23:34:50Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzM2NjA1",
          "commit": {
            "abbreviatedOid": "aaed29f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-07T10:29:39Z",
          "updatedAt": "2020-03-07T10:29:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Fair point Jana, ignore my suggestion Matt.",
              "createdAt": "2020-03-07T10:29:39Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MjcyNDk5",
          "commit": {
            "abbreviatedOid": "7f1888f"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, @mjoras -- a few more suggestions.",
          "createdAt": "2020-03-18T22:13:40Z",
          "updatedAt": "2020-03-19T00:20:00Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nstrategies and find those which best suit their applications and congestion\r\n```",
              "createdAt": "2020-03-18T22:13:40Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nMany congestion control algorithms have a startup mechanism during the beginning\r\n```",
              "createdAt": "2020-03-18T22:14:40Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nof a connection.  It is typical that in this period the congestion controller\r\n```",
              "createdAt": "2020-03-18T22:14:55Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nacknowledgments at a rate which is optimal for the the sender's congestion\r\n```",
              "createdAt": "2020-03-18T22:15:20Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\ncongestion controller is in this state, ensuring that the receiver will send\r\n```",
              "createdAt": "2020-03-18T22:15:37Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\ncontroller's machinery.  A sender can send ACK_FREQUENCY frames while its\r\n```",
              "createdAt": "2020-03-18T22:15:58Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\ncontroller.\r\n```",
              "createdAt": "2020-03-18T22:16:35Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\ncontrollers rely on the timing of peer acknowledgments (an \"ACK clock\") to send\r\ndata, delaying acknowledgments will cause undesirable bursts of data into the\r\nnetwork.\r\n```",
              "createdAt": "2020-03-19T00:09:55Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            },
            {
              "originalPosition": 4,
              "body": "I think deleting this text here leads to the impression that there are only good things that can come out of reducing ACK rate, which leads to the question, why not simply reduce it. I think it's important to note the other points here, and maybe point to the considerations section. How about something like:\r\n\r\n> As discussed in {{implementation}}, there are undesirable consequences to a receiver unilaterally\r\n> reducing the acknowledgement frequency however, in terms of congestion control and loss\r\n> detection. Consequently, a sender needs the ability to express its constraints on the acknowledgement \r\n> frequency to maximize congestion controller performance.\"",
              "createdAt": "2020-03-19T00:18:01Z",
              "updatedAt": "2020-03-19T19:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTUzMjUy",
          "commit": {
            "abbreviatedOid": "2e3c981"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @mjoras!",
          "createdAt": "2020-03-19T23:08:45Z",
          "updatedAt": "2020-03-19T23:08:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk5Mzc0NzY2",
      "title": "use TRANSPORT_PARAMETER_ERROR",
      "url": "https://github.com/quicwg/ack-frequency/pull/32",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use TRANSPORT_PARAMETER_ERROR for communicating errors in TP, rather than using PROTOCOL_VIOLATION.",
      "createdAt": "2020-04-06T04:37:02Z",
      "updatedAt": "2020-04-18T21:02:56Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "a2283352a7314e730d43681fdac31a54cfab2c7e",
      "headRepository": "kazuho/ack-frequency",
      "headRefName": "kazuho/error-code-for-tp",
      "headRefOid": "52a3464e435320737aefdd7ead30c3c326734321",
      "closedAt": "2020-04-18T21:02:56Z",
      "mergedAt": "2020-04-18T21:02:56Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "bc49468c91497a37105082eb50aa0fd5b2723858"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTI5MDY2",
          "commit": {
            "abbreviatedOid": "52a3464"
          },
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T04:38:11Z",
          "updatedAt": "2020-04-06T04:38:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMDIzNzQw",
      "title": "follow the practice of using PROTOCOL_VIOLATION for semantic errors",
      "url": "https://github.com/quicwg/ack-frequency/pull/33",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the specification requires the use of FRAME_ENCODING_ERROR when an endpoint receives an ACK_FREQUENCY frame with the value of Update Max Ack Delay field being smaller than `min_ack_delay`.\r\n\r\nThat contradicts from the practice of the core draft, that restricts the use of FRAME_ENCODING_ERROR to syntactic (i.e. encoding) errors.\r\n\r\nThis PR fixes the problem by changing the error code to be used in that case to PROTOCOL_VIOLATION.\r\n",
      "createdAt": "2020-04-07T04:01:54Z",
      "updatedAt": "2020-04-18T21:03:17Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "a2283352a7314e730d43681fdac31a54cfab2c7e",
      "headRepository": "kazuho/ack-frequency",
      "headRefName": "kazuho/semantic-error-is-not-frame-encoding-error",
      "headRefOid": "c97fff0520df677956dbeb9de9a0f8858b1f5d68",
      "closedAt": "2020-04-18T21:03:17Z",
      "mergedAt": "2020-04-18T21:03:17Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MzgyNjI0",
          "commit": {
            "abbreviatedOid": "c97fff0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-07T18:29:43Z",
          "updatedAt": "2020-04-07T18:29:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3OTg3NTEx",
      "title": "Replace 'Ignore Order' with 'Packet Loss Threshold'",
      "url": "https://github.com/quicwg/ack-frequency/pull/36",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35 by specifying a 'Packet Loss Threshold' field which allows the sender of the frame to communicate the packet loss threshold to the receiver, avoiding unnecessary immediate ACKs and speeding up loss detection.",
      "createdAt": "2020-04-23T15:09:30Z",
      "updatedAt": "2021-09-08T12:12:29Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-packet-loss-threshold",
      "headRefOid": "ec27899e2dd6eca6b474c26d9e989de52f63df63",
      "closedAt": "2021-09-08T12:07:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The direction is to not add this unless there's clear justification of its value, so closing.  Also, it's clear the PR was confusing as written.",
          "createdAt": "2021-09-08T12:12:29Z",
          "updatedAt": "2021-09-08T12:12:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDQ3MzU5",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T05:43:46Z",
          "updatedAt": "2020-08-07T05:43:47Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I don't know how to implement this.  Or maybe it's just a bug.\r\n\r\nLet's say that I acknowledged packet 10.  The packet loss threshold is 4.  As stated, this says: acknowledge immediately if you receive packet 15.  That seems OK.\r\n\r\nBut if I acknowledge 10, but 9 has not been received, this text implies that receiving 13 would cause an immediate ACK.  That seems like it might always result in an immediate ACK over time:\r\n\r\n```\r\nif pn > largest_received:\r\n  largest_received = pn\r\n  for n in 0..(largest_received - loss_threshold):\r\n    if !received(n):\r\n      send_immediate_ack()\r\n      break\r\n```\r\n\r\nIf instead this is something like:\r\n\r\n```\r\nif pn > largest_received:\r\n  largest_received = pn\r\n  if loss_threshold > 0 && largest_received > largest_acked + loss_threshold:\r\n    for n in (largest_acked + 1)..(largest_received - loss_threshold):\r\n      if !received(n):\r\n        send_immediate_ack()\r\n        break\r\n```\r\n\r\nThat might be a reason to include the largest acknowledged in the calculation.\r\n\r\nAssuming the latter is your intent, as this requires iteration over `loss_threshold` packets, receivers should be allowed to limit the size of this value arbitrarily to avoid O(N) work for little attacker cost.",
              "createdAt": "2020-08-07T05:43:46Z",
              "updatedAt": "2020-08-07T05:43:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDg5MTY3",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T07:21:51Z",
          "updatedAt": "2020-08-07T07:21:52Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "FWIW, I tend to think that the latter is the correct thing to do. But at the same time, I would argue against allowing the receiver to set an arbitrary maximum for the loss_threshold field, as that prevents the sender from using a loss_threshold as a way of asking the receiver to ignore order.\r\n\r\nIn practice, I would assume that a receiver would be using a list of ranges (i.e. ack blocks) for representing what needs to be sent in an ACK frame. Typically, the number of blocks will exceed an internal threshold and trigger an ack before the attack being described here becomes an issue. I would be fine with pointing that out explicitly, and that would work as a mitigation.",
              "createdAt": "2020-08-07T07:21:51Z",
              "updatedAt": "2020-08-07T07:21:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMTA5MTIy",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T07:56:07Z",
          "updatedAt": "2020-08-07T07:56:08Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "As a followup to this.  I tried implementing this and realized that if you hold ranges of packets, you can do something sensible without having to limit the value of `loss_threshold`, but it isn't very easy to think about.\r\n\r\nIf you haven't sent an ACK yet, then you can check that the `range.min > 0` and `range.max > loss_threshold`.  This says that the range of unacknowledged packets you have received doesn't start at 0 and there might be more than `loss_threshold` packets outstanding.  This bit gets a little sketchy when people start packet numbers at numbers greater than 0, but I think that the immediate ACK there is tolerable in that case, because it happens just once when it might not be desirable (that is, for the first application data packet).\r\n\r\nIf you have sent an ACK including `largest`, then you check that `range.min > largest + 1` and `range.max > largest + loss_threshold`.\r\n\r\nThis only works if you merge ranges properly when receiving packets.  For instance, when receiving packets 3, 1, and 2 in that order, you produce a single range that covers 1 to 3 and not separate ranges.  Merging ranges is fairly straightforward, and you more or less have to it to construct valid ACK frames, but it's worth noting.\r\n\r\nI ultimately track the *next* packet that needs acknowledgment rather than the largest (this saves errors at 0), and so I get:\r\n\r\n```\r\non_received(pn):\r\n\r\nranges.add(pn)\r\nif pn == ranges.largest().max {\r\n  # this just extended the most recent range\r\n  last_packet_time = now()\r\n  if loss_threshold > 0:\r\n    reordered = next_unacknowledged < ranges.largest().min && pn >= next_unacknowledged + loss_threshold\r\n  else:\r\n    reordered = false\r\nelse:\r\n  reordered = pn < next_unacknowledged\r\nendif\r\n```",
              "createdAt": "2020-08-07T07:56:08Z",
              "updatedAt": "2020-08-07T07:56:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjc3NTc3",
          "commit": {
            "abbreviatedOid": "ec27899"
          },
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T12:38:41Z",
          "updatedAt": "2020-08-07T12:38:42Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "~~The way I'd solve this is to look up the oldest unacked packet.  This packet would have the smallest packet number.  This is the packet number to subtract from `largest_received`; the difference is to be compared with `loss_threshold`.~~\r\n\r\nEdit: post-coffee I realize that this is not what's intended.",
              "createdAt": "2020-08-07T12:38:42Z",
              "updatedAt": "2020-08-07T12:49:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyODk1NjYy",
      "title": "CE is covered in section 13.2.1 of transport draft",
      "url": "https://github.com/quicwg/ack-frequency/pull/39",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-04T17:12:13Z",
      "updatedAt": "2021-07-12T16:54:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "dtikhonov/ack-frequency",
      "headRefName": "patch-1",
      "headRefOid": "0e333c4e40330d713d0d394210fcbbbd6f32e227",
      "closedAt": "2021-07-12T16:54:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDIxNjY5",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-04T17:27:45Z",
          "updatedAt": "2020-08-04T17:27:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MTA3ODM3",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-11T07:21:36Z",
          "updatedAt": "2021-01-11T07:21:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzM4MzEy",
          "commit": {
            "abbreviatedOid": "0e333c4"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:54:28Z",
          "updatedAt": "2021-07-12T16:54:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzI2NjY3",
      "title": "Change codepoints to avoid conflict with draft revisions",
      "url": "https://github.com/quicwg/ack-frequency/pull/41",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We don't need to change the frame type on each draft version, but I figured that it'd be safer.",
      "createdAt": "2020-11-02T21:22:40Z",
      "updatedAt": "2020-11-02T23:47:35Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "8ba2ebbc82a2259ee8dd3b995c06febb3e78a71d",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/opcode",
      "headRefOid": "3720428fe2c323fae8715e9fc3afdda3ec974ef5",
      "closedAt": "2020-11-02T23:47:34Z",
      "mergedAt": "2020-11-02T23:47:34Z",
      "mergedBy": "janaiyengar",
      "mergeCommit": {
        "oid": "35fed220a6b7a52ddcdecab495f902216c7d6969"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODQwNDkw",
      "title": "min_ack_delay is a unilateral indication",
      "url": "https://github.com/quicwg/ack-frequency/pull/47",
      "state": "MERGED",
      "author": "nibanks",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #42. Clearly declares that the TP only works in one direction.",
      "createdAt": "2021-03-05T19:56:40Z",
      "updatedAt": "2021-04-19T18:37:46Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "35fed220a6b7a52ddcdecab495f902216c7d6969",
      "headRepository": "nibanks/ack-frequency",
      "headRefName": "patch-1",
      "headRefOid": "31c0570abcdfcf1dce02e2c1b2c5f20e1d3429e4",
      "closedAt": "2021-04-19T18:37:46Z",
      "mergedAt": "2021-04-19T18:37:46Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5e83cc8190b4eccea997fc7d1ddfd7520240533c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTkzMzM3",
          "commit": {
            "abbreviatedOid": "053d1bb"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-05T20:58:22Z",
          "updatedAt": "2021-03-05T20:58:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'd drop this sentence, since it's not quite saying what you want to say at the moment and I think the paragraph works without it.\r\n\r\n```suggestion\r\nreceiving ACK_FREQUENCY frames.  If an endpoint sends the transport parameter, the peer\r\n```",
              "createdAt": "2021-03-05T20:58:22Z",
              "updatedAt": "2021-03-05T21:01:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MjEzMDky",
          "commit": {
            "abbreviatedOid": "31c0570"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-15T23:22:28Z",
          "updatedAt": "2021-04-15T23:22:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcwNzkwMDE0",
      "title": "Change title, fix refs",
      "url": "https://github.com/quicwg/ack-frequency/pull/50",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-15T22:16:59Z",
      "updatedAt": "2021-06-15T22:44:27Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "master",
      "baseRefOid": "f97243281aa4a399bc43018c52288bee8cb7e9f6",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/title",
      "headRefOid": "cccc4c71cdccd947aa725d1a662a22bc1e056b74",
      "closedAt": "2021-06-15T22:41:51Z",
      "mergedAt": "2021-06-15T22:41:51Z",
      "mergedBy": "mjoras",
      "mergeCommit": {
        "oid": "43953203d3a285090f1922c1554a9fce1312e620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTM5MDE0",
          "commit": {
            "abbreviatedOid": "80450a2"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-15T22:17:48Z",
          "updatedAt": "2021-06-15T22:17:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0NTUyMjgw",
          "commit": {
            "abbreviatedOid": "cccc4c7"
          },
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T22:44:26Z",
          "updatedAt": "2021-06-15T22:44:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\ndocname: draft-ietf-quic-ack-frequency-latest\r\n```",
              "createdAt": "2021-06-15T22:44:26Z",
              "updatedAt": "2021-06-15T22:44:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4OTM4NDc5",
      "title": "fixup links to repo and list",
      "url": "https://github.com/quicwg/ack-frequency/pull/52",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-28T10:58:51Z",
      "updatedAt": "2021-06-28T16:41:40Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "0ac7e5e950b5d705ee9f89d9ea8c0d2056a3fd3e",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "lucas/fixup-discussion-links",
      "headRefOid": "67d85a6502acfa9df7b34faadc5e60a152add0e9",
      "closedAt": "2021-06-28T16:41:40Z",
      "mergedAt": "2021-06-28T16:41:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "cacf0485084e3638dcb0fcf805d06a55a3dd248a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MTcwNTk0",
          "commit": {
            "abbreviatedOid": "67d85a6"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T16:41:36Z",
          "updatedAt": "2021-06-28T16:41:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MDA2Mjc4",
      "title": "Fix CE section reference",
      "url": "https://github.com/quicwg/ack-frequency/pull/54",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Copy of #39, applied to new draft filename.\r\nCloses #39.",
      "createdAt": "2021-07-12T16:54:18Z",
      "updatedAt": "2021-07-12T16:54:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "cacf0485084e3638dcb0fcf805d06a55a3dd248a",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "fixsection",
      "headRefOid": "f2ac9f2ec0e3ce17712a9d3f992608cd1df2ad00",
      "closedAt": "2021-07-12T16:54:42Z",
      "mergedAt": "2021-07-12T16:54:42Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "18b674861d099a9053919c7c1543e5eccee0c6df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzM4NDQ3",
          "commit": {
            "abbreviatedOid": "f2ac9f2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:54:36Z",
          "updatedAt": "2021-07-12T16:54:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4MDIwOTU2",
      "title": "Rename 'Packet Tolerance' to 'ACK-Eliciting Threshold'",
      "url": "https://github.com/quicwg/ack-frequency/pull/55",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Part of #27\r\n\r\nWe still need to decide whether to change 'Update Max Ack Delay' to 'Max Ack Delay'.",
      "createdAt": "2021-07-12T17:13:43Z",
      "updatedAt": "2021-07-29T14:39:24Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "e5b46f2888aa5dc87daac3a430b5d4c832d5dd9a",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-ack-eliciting-threshold",
      "headRefOid": "d2a84dcf14dfe1884ae92d8c6af83b27ad299436",
      "closedAt": "2021-07-29T14:39:24Z",
      "mergedAt": "2021-07-29T14:39:24Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "a458009b1828cf719b2c5499e72b419956f65a0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0Mzg1ODI1",
          "commit": {
            "abbreviatedOid": "aeb4036"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T17:48:21Z",
          "updatedAt": "2021-07-12T17:49:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n|                  Ack-Eliciting Threshold (i)                ...\r\n```",
              "createdAt": "2021-07-12T17:48:21Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nAck-Eliciting Threshold:\r\n```",
              "createdAt": "2021-07-12T17:48:33Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nis recorded as the largest seen sequence number. The new Ack-Eliciting Threshold\r\n```",
              "createdAt": "2021-07-12T17:48:44Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nand `Ack-Eliciting Threshold` values ({{multiple-frames}}), the endpoint MUST send an\r\n```",
              "createdAt": "2021-07-12T17:48:53Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n  packets is greater than or equal to the recorded `Ack-Eliciting Threshold`.\r\n```",
              "createdAt": "2021-07-12T17:49:02Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n`Ack-Eliciting Threshold` and `max_ack_delay` thresholds for sending\r\n```",
              "createdAt": "2021-07-12T17:49:12Z",
              "updatedAt": "2021-07-12T17:49:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDU4Nzc5",
      "title": "Change Update Max Ack Delay to Request Max Ack Delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/56",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes the remainder of #27 not fixed by #55",
      "createdAt": "2021-07-22T19:58:27Z",
      "updatedAt": "2021-09-09T23:55:36Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-request-max-ack-delay",
      "headRefOid": "5520d9fa7d2e35d7c83115097f52009447a1f9b7",
      "closedAt": "2021-09-09T23:55:36Z",
      "mergedAt": "2021-09-09T23:55:36Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2d9681036b0c69cc08c050604e81863cc14d0df2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDE3Njcz",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One suggestion, but looks good to me otherwise.",
          "createdAt": "2021-07-23T18:11:23Z",
          "updatedAt": "2021-07-23T18:30:06Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Suggestion: \"A variable-length integer representing the value to which the endpoint requests the peer to update its `max_ack_delay` (Section 18.2 of {{QUIC-TRANSPORT}}).\"",
              "createdAt": "2021-07-23T18:29:08Z",
              "updatedAt": "2021-07-23T18:30:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4NTEx",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:48:12Z",
          "updatedAt": "2021-07-24T11:48:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI5Njgz",
          "commit": {
            "abbreviatedOid": "adb702e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T12:07:25Z",
          "updatedAt": "2021-07-24T12:07:25Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I went with your suggestion with one less 'to'. It's definitely more correct, but I'd like to find something easier to read.\r\n\r\nI came up with the following, but I'm not sure it's better:\r\n\"A variable-length integer representing the updated max_ack_delay (Section 18.2 of {{QUIC-TRANSPORT}}) value the endpoint is requesting of the peer.\"",
              "createdAt": "2021-07-24T12:07:25Z",
              "updatedAt": "2021-07-24T12:07:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTA0NTI5",
          "commit": {
            "abbreviatedOid": "92f1388"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is good enough. You have a conflict to resolve, but let's merge this.",
          "createdAt": "2021-09-09T22:43:46Z",
          "updatedAt": "2021-09-09T22:43:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NDc1OTY3",
      "title": "Set limits to min_ack_delay and max_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/57",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #43.\r\nCloses #44.",
      "createdAt": "2021-07-22T20:25:01Z",
      "updatedAt": "2021-07-31T01:15:52Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/min-max",
      "headRefOid": "8a87dbd3d38c40507a2ca346f242fbdee3866ec3",
      "closedAt": "2021-07-31T01:15:52Z",
      "mergedAt": "2021-07-31T01:15:51Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzMzI1NjAy",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T00:16:42Z",
          "updatedAt": "2021-07-23T00:16:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzNzgyNTMz",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T14:25:17Z",
          "updatedAt": "2021-07-23T14:25:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4NDU0",
          "commit": {
            "abbreviatedOid": "8a87dbd"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:47:01Z",
          "updatedAt": "2021-07-24T11:47:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1NTk3MzE2",
      "title": "Tweak ack-eliciting threshold.",
      "url": "https://github.com/quicwg/ack-frequency/pull/58",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #49\r\n\r\nAlso updates the transport parameter codepoint to 0xff03de1a from 0xff02de1a.",
      "createdAt": "2021-07-23T00:45:44Z",
      "updatedAt": "2021-09-10T00:24:46Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "2d9681036b0c69cc08c050604e81863cc14d0df2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-tweak-ack-threshold",
      "headRefOid": "4311a922f4c2d79e25bd37aaa27d80638fa56eec",
      "closedAt": "2021-09-10T00:24:46Z",
      "mergedAt": "2021-09-10T00:24:45Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "71ec632906f12388cf6623399d3deac3c2d59585"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzNzgxMTEw",
          "commit": {
            "abbreviatedOid": "0b83fda"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T14:24:04Z",
          "updatedAt": "2021-07-23T14:24:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I believe you are missing a word (`packets`?) between `ack-eliciting` and `you can`.",
              "createdAt": "2021-07-23T14:24:04Z",
              "updatedAt": "2021-07-23T14:24:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzODQ3NTEx",
          "commit": {
            "abbreviatedOid": "0b83fda"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T15:31:43Z",
          "updatedAt": "2021-07-23T15:31:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yes, thanks.",
              "createdAt": "2021-07-23T15:31:43Z",
              "updatedAt": "2021-07-23T15:31:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzODUwNDUw",
          "commit": {
            "abbreviatedOid": "1ce9b5f"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T15:34:49Z",
          "updatedAt": "2021-07-23T15:34:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDMxODQy",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T18:31:12Z",
          "updatedAt": "2021-07-23T19:01:10Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nmin_ack_delay (0xff03de1a):\r\n```",
              "createdAt": "2021-07-23T18:31:12Z",
              "updatedAt": "2021-07-23T19:01:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0NDYz",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T07:41:53Z",
          "updatedAt": "2021-07-24T07:41:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nmin_ack_delay (0x9a7eb021):\r\n```\r\n\r\nGenerating a fresh value is a) good hygiene, b) easy.",
              "createdAt": "2021-07-24T07:41:54Z",
              "updatedAt": "2021-07-24T07:41:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjE0NTI3",
          "commit": {
            "abbreviatedOid": "f92fbf5"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-24T07:42:58Z",
          "updatedAt": "2021-07-24T07:42:58Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"you\"?\r\n\r\nThis is the maximum number of ack-eliciting packets that the recipient of this frame can receive without sending an immediate acknowledgment.",
              "createdAt": "2021-07-24T07:42:58Z",
              "updatedAt": "2021-07-24T07:42:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0NjkyMjM3",
          "commit": {
            "abbreviatedOid": "d1f68ef"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-26T10:35:42Z",
          "updatedAt": "2021-07-26T10:35:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I took Jana's suggestion, but don't have a strong opinion between similar codepoints and random ones.",
              "createdAt": "2021-07-26T10:35:42Z",
              "updatedAt": "2021-07-26T10:35:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0NjkzNTEy",
          "commit": {
            "abbreviatedOid": "d1f68ef"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-26T10:37:21Z",
          "updatedAt": "2021-07-26T10:37:21Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks",
              "createdAt": "2021-07-26T10:37:21Z",
              "updatedAt": "2021-07-26T10:37:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzQ0MTcw",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "ekinnear",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:23:50Z",
          "updatedAt": "2021-07-27T20:23:51Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Is there a way to phrase this such that the off-by-one-ness is intuitive?\r\nSomething along the lines of \"the number of packets after the most-recently-acked one to skip before sending another ack\".\r\n\r\nSo saying \"skip zero packets\" means ack every time, saying \"skip one packet after the most recently acked one\" means ack every-other. \r\n\r\nStill trying to come up with a nice way to word that, but it seems like it could reduce off-by-one confusion.",
              "createdAt": "2021-07-27T20:23:50Z",
              "updatedAt": "2021-07-27T20:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzY0ODAz",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:48:57Z",
          "updatedAt": "2021-07-27T20:48:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'm definitely open to other wordings.  I think the example of 0 helps for me, but suggestions are welcome.",
              "createdAt": "2021-07-27T20:48:57Z",
              "updatedAt": "2021-07-27T20:48:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2Mzg3ODAy",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T21:18:22Z",
          "updatedAt": "2021-07-27T21:18:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The phrasing I used was \"the number of packets you can receive without sending an immediate acknowledgment\". So has Ian. Isn't that intuitive enough?",
              "createdAt": "2021-07-27T21:18:22Z",
              "updatedAt": "2021-07-27T21:19:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTA2ODUz",
          "commit": {
            "abbreviatedOid": "5673dc2"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T22:48:33Z",
          "updatedAt": "2021-09-09T22:55:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n  packets the recipient of this frame can receive without sending an immediate\r\n```",
              "createdAt": "2021-09-09T22:48:33Z",
              "updatedAt": "2021-09-09T22:55:55Z"
            },
            {
              "originalPosition": 19,
              "body": "The text is slightly but enough different to the suggestion you made, @martinthomson. I think we should replace \"before\" with \"without\".",
              "createdAt": "2021-09-09T22:48:38Z",
              "updatedAt": "2021-09-09T22:55:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTA5Njg3",
      "title": "Cap ACK-eliciting threshold if the received value is too large",
      "url": "https://github.com/quicwg/ack-frequency/pull/59",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #45",
      "createdAt": "2021-07-23T17:35:14Z",
      "updatedAt": "2021-07-31T01:13:42Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-cap-ack-eliciting-threshold",
      "headRefOid": "4e904ce9048a34c6a33a15b86e033fa83615ef4d",
      "closedAt": "2021-07-31T01:13:42Z",
      "mergedAt": "2021-07-31T01:13:42Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "88d9c0bf8298d3c7ba02556a0ffa4870c2652532"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEzOTY0NTEx",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T17:37:13Z",
          "updatedAt": "2021-07-23T17:37:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDkzMzgy",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T20:07:55Z",
          "updatedAt": "2021-07-23T20:07:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MDk4",
          "commit": {
            "abbreviatedOid": "7fb52e4"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:40:16Z",
          "updatedAt": "2021-07-24T11:40:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "The largest representable value is by definition the maximum value.\r\n```suggestion\r\n  value instead.\r\n```",
              "createdAt": "2021-07-24T11:40:16Z",
              "updatedAt": "2021-07-24T11:40:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTE2ODIy",
      "title": "MAY omit the max_ack_delay if enough packets are in flight",
      "url": "https://github.com/quicwg/ack-frequency/pull/60",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #37 by allowing implementations to not add max_ack_delay to the PTO calculation if enough ack-eliciting packets are in flight.",
      "createdAt": "2021-07-23T17:49:54Z",
      "updatedAt": "2021-09-10T07:15:35Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "89980ef76468ce41df2e11cbc6244eb0f7a78753",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-omit-max-ack-delay",
      "headRefOid": "cda2f6719c14f81ad3ac09937435f8b2dc57648e",
      "closedAt": "2021-09-10T07:15:35Z",
      "mergedAt": "2021-09-10T07:15:35Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5aeebefc3a0e33d69b5b830663f2fa7c78368299"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann Does Jana's longer explanation help or would you like more clarification?",
          "createdAt": "2021-07-27T00:08:37Z",
          "updatedAt": "2021-07-27T00:08:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MDk3MDg0",
          "commit": {
            "abbreviatedOid": "694afdd"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T20:14:01Z",
          "updatedAt": "2021-07-23T20:14:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nACK-Eliciting Threshold, an endpoint can expect that the peer\r\nwill not need to wait for its `max_ack_delay` period before\r\nsending an acknowledgement. In such cases, the endpoint MAY\r\ntherefore exclude the peer's 'max_ack_delay' from its PTO\r\ncalculation.\r\n```",
              "createdAt": "2021-07-23T20:14:01Z",
              "updatedAt": "2021-07-23T20:14:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MjY4",
          "commit": {
            "abbreviatedOid": "694afdd"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure I understand the motivation for this (I'm also having trouble following the issue). Can we add some more explanation here?",
          "createdAt": "2021-07-24T11:43:01Z",
          "updatedAt": "2021-07-24T11:43:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1ODE4NjIw",
          "commit": {
            "abbreviatedOid": "e053319"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T11:55:20Z",
          "updatedAt": "2021-07-27T11:55:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTgyNDU5",
          "commit": {
            "abbreviatedOid": "e053319"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "one suggestion, but lgtm otherwise.",
          "createdAt": "2021-09-10T01:52:20Z",
          "updatedAt": "2021-09-10T01:52:39Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ncalculation. Note that this optimization requires some care in implementation, since\r\nit can cause premature PTOs under packet loss when `ignore_order` is enabled.\r\n```",
              "createdAt": "2021-09-10T01:52:20Z",
              "updatedAt": "2021-09-10T01:52:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MTk2NTU4",
      "title": "Don't change ack behavior until ACK_FREQUENCY is received",
      "url": "https://github.com/quicwg/ack-frequency/pull/61",
      "state": "MERGED",
      "author": "janaiyengar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #25.",
      "createdAt": "2021-07-23T20:34:18Z",
      "updatedAt": "2021-09-10T16:23:50Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "fae9484977b8bb16ead9bcace6e81727d5051571",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "jri/tp-only",
      "headRefOid": "810155d0d1be47d8abb0acc91daa237f56a444a1",
      "closedAt": "2021-09-10T16:23:50Z",
      "mergedAt": "2021-09-10T16:23:50Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "eccfdbe87babccd5294d3264c7627de0f5b08091"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MTA5NzIw",
          "commit": {
            "abbreviatedOid": "c68c59d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-23T20:35:55Z",
          "updatedAt": "2021-07-23T20:35:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nreceiving this transport parameter does not cause the endpoint to\r\n```",
              "createdAt": "2021-07-23T20:35:55Z",
              "updatedAt": "2021-07-23T20:35:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MTE4OTg2",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-23T20:52:36Z",
          "updatedAt": "2021-07-23T20:52:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI3OTc3",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:38:02Z",
          "updatedAt": "2021-07-24T11:38:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjI4MzIw",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-24T11:44:01Z",
          "updatedAt": "2021-07-24T11:44:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE0MjUyMDEz",
          "commit": {
            "abbreviatedOid": "51e9ed1"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2021-07-24T18:17:31Z",
          "updatedAt": "2021-07-24T18:17:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAwNjMxNTUz",
      "title": "MUST NOT store min_ack_delay",
      "url": "https://github.com/quicwg/ack-frequency/pull/63",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Closes #22 and #40\r\n\r\nAnd by implication, cannot send ACK_FREQUENCY in 0-RTT packets.",
      "createdAt": "2021-07-31T01:10:21Z",
      "updatedAt": "2021-09-10T16:15:48Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "a458009b1828cf719b2c5499e72b419956f65a0b",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-dont-store-min-ack-delay",
      "headRefOid": "c0084a4105c45d36a77f0eab46a8432e6eb0d35f",
      "closedAt": "2021-09-10T16:15:48Z",
      "mergedAt": "2021-09-10T16:15:48Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fae9484977b8bb16ead9bcace6e81727d5051571"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NjEwMDU2",
          "commit": {
            "abbreviatedOid": "5e664b1"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-31T23:49:14Z",
          "updatedAt": "2021-07-31T23:49:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Please drop this last sentence.",
              "createdAt": "2021-07-31T23:49:15Z",
              "updatedAt": "2021-07-31T23:49:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwMjEyNzU1",
          "commit": {
            "abbreviatedOid": "5e664b1"
          },
          "author": "kazuho",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you for the PR. Looks good, below is nothing more than an editorial preference.",
          "createdAt": "2021-08-02T13:38:08Z",
          "updatedAt": "2021-08-02T13:39:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "How about going like:\r\n```suggestion\r\nEndpoints MUST NOT remember the value of min_ack_delay transport parameter they received.\r\n```\r\n\r\nI think provision of the first sentence (\"An endpoint MUST NOT send ACK_FREQUENCY frames until ...\") is covered by the last sentence of the previous paragraph. If we think that that sentence is vague, we can change \"if\" of that sentence to \"if and only if.\"\r\n\r\nRegarding the second sentence, my preference goes to using the phrase \"remembered\" and talking about both sides, because that is what RFC 9000 does.",
              "createdAt": "2021-08-02T13:38:08Z",
              "updatedAt": "2021-08-02T13:39:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNzI2MjU3",
          "commit": {
            "abbreviatedOid": "e5e173c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T02:27:14Z",
          "updatedAt": "2021-08-03T02:27:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I took Kazuho's suggestion, which I think is correct based on the discussion on #22?",
              "createdAt": "2021-08-03T02:27:14Z",
              "updatedAt": "2021-08-03T02:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNzI2NTUx",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T02:28:00Z",
          "updatedAt": "2021-08-03T02:28:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks, suggestion accepted.",
              "createdAt": "2021-08-03T02:28:00Z",
              "updatedAt": "2021-08-03T02:28:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxMTIxMzQz",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-03T12:14:00Z",
          "updatedAt": "2021-08-03T12:14:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNzM4MTk2",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-04T00:06:11Z",
          "updatedAt": "2021-08-04T00:06:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTg0MTY2",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "janaiyengar",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "couple of suggestions, but lgtm",
          "createdAt": "2021-09-10T01:56:51Z",
          "updatedAt": "2021-09-10T01:59:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nthey received. Consequently, ACK_FREQUENCY frames MUST NOT be sent in 0-RTT\r\n```",
              "createdAt": "2021-09-10T01:56:51Z",
              "updatedAt": "2021-09-10T01:59:38Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\npackets, as per Section 7.4.1 of {{QUIC-TRANSPORT}}.\r\n```",
              "createdAt": "2021-09-10T01:59:18Z",
              "updatedAt": "2021-09-10T01:59:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwOTg3MTkw",
          "commit": {
            "abbreviatedOid": "436b33b"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T02:05:07Z",
          "updatedAt": "2021-09-10T02:05:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "isn't it \"cannot\"?\r\n\r\n(You see, if we say \"MUST NOT\", we probably need to say what happens if you get a 0-RTT packet with ACK_FREQUENCY in it, but I know that some implementations can't really make that distinction.)",
              "createdAt": "2021-09-10T02:05:07Z",
              "updatedAt": "2021-09-10T02:05:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMTEwODIz",
          "commit": {
            "abbreviatedOid": "983de2c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-10T07:13:05Z",
          "updatedAt": "2021-09-10T07:13:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good point, I think cannot is more correct, updated.",
              "createdAt": "2021-09-10T07:13:05Z",
              "updatedAt": "2021-09-10T07:13:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMzQ0Mjk4",
          "commit": {
            "abbreviatedOid": "c0084a4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-10T12:13:42Z",
          "updatedAt": "2021-09-10T12:13:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI5NjAyNTY3",
      "title": "Add an IMMEDIATE_ACK frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/64",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Fixes #34 by adding a one byte IMMEDIATE_ACK frame.",
      "createdAt": "2021-09-08T12:30:33Z",
      "updatedAt": "2021-09-11T08:55:30Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "b8a834e72d9d14aa366e81fe5f9ddedd4bf73eb2",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-immediate-ack",
      "headRefOid": "5de63028efff6d30e523351429a536b1e15bdab8",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "MEMBER",
          "body": "editorial nit: my preference would be for frame diagrams to use the notation in QUIC transport. I see that ACK_FREQUENCY is defined using ASCII art, so perhaps you want to consider a separate follow up PR to switch styles after this lands.",
          "createdAt": "2021-09-08T12:35:12Z",
          "updatedAt": "2021-09-08T12:35:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Lucas, I filed #66 to update them.",
          "createdAt": "2021-09-08T15:50:21Z",
          "updatedAt": "2021-09-08T15:50:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxMzQ0OTc4",
          "commit": {
            "abbreviatedOid": "2235bf4"
          },
          "author": "nibanks",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-10T12:14:36Z",
          "updatedAt": "2021-09-10T12:14:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxODk5MjAy",
      "title": "Add a DELAY_ACK frame",
      "url": "https://github.com/quicwg/ack-frequency/pull/67",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "This frame overrides the behavior of IMMEDIATE_ACK, if the two were to be placed in the same packet.  This would of course be silly, but I don't think it's worth disallowing given the lack of harm.\r\n\r\nFixes #65",
      "createdAt": "2021-09-11T08:51:21Z",
      "updatedAt": "2021-09-14T00:37:13Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "eccfdbe87babccd5294d3264c7627de0f5b08091",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-no-ack",
      "headRefOid": "e25e0d9a8ce01e74404628da8229162e1507aa5d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "1) Do we really need this?\r\n2) What happens if the receiver ignores the frame and just acks the packet?\r\n3) If a packet contains both immediate_ack and no_ack, the reaction should be \"protocol error\", not \"ignore one and pick the other\".",
          "createdAt": "2021-09-13T00:18:30Z",
          "updatedAt": "2021-09-13T00:18:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxOTk2MjQ2",
      "title": "ACK less frequently when CE marks are received",
      "url": "https://github.com/quicwg/ack-frequency/pull/68",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Per @bbriscoe's suggestion in #48, this PR changes the immediate ACK behavior to only send an immediate ACK when max(2, Ack-Eliciting Threshold) packets with CE marks have been received.\r\n\r\nFixes #48",
      "createdAt": "2021-09-11T20:14:21Z",
      "updatedAt": "2021-09-14T00:43:04Z",
      "baseRepository": "quicwg/ack-frequency",
      "baseRefName": "main",
      "baseRefOid": "eccfdbe87babccd5294d3264c7627de0f5b08091",
      "headRepository": "quicwg/ack-frequency",
      "headRefName": "ianswett-ce-immediate-ack",
      "headRefOid": "4b138838039d5694b52b52287d37487d41f97ce5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm wondering if this should be max(2, Ack-Eliciting Threshold)/2 instead?\r\n\r\nAs it is, except for the immediate ack on unmarked to CE marked, this algorithm basically doesn't change acknowledgement behavior at all.",
          "createdAt": "2021-09-12T13:19:24Z",
          "updatedAt": "2021-09-12T13:19:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyMjI4ODU3",
          "commit": {
            "abbreviatedOid": "b44b55d"
          },
          "author": "martinthomson",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-12T23:47:57Z",
          "updatedAt": "2021-09-12T23:50:48Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nAn endpoint SHOULD send an immediate acknowledgement when a packet marked\r\n```",
              "createdAt": "2021-09-12T23:47:57Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nreceived and the previous packet was not marked CE.\r\n```",
              "createdAt": "2021-09-12T23:48:34Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncompared to {{Section 13.2.1 of QUIC-TRANSPORT}} when peers are using\r\n```",
              "createdAt": "2021-09-12T23:49:14Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            },
            {
              "originalPosition": 14,
              "body": "How about\r\n> An endpoint SHOULD reduce its Ack-Eliciting Threshold to at most 2 when acknowledging a contiguous series of CE marked packets.",
              "createdAt": "2021-09-12T23:50:42Z",
              "updatedAt": "2021-09-12T23:50:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyMjMyNDA2",
          "commit": {
            "abbreviatedOid": "b44b55d"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-13T00:13:10Z",
          "updatedAt": "2021-09-13T00:13:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This line is a bit confusing. I think we can separate out `reduces the peer's response time to congestion events` and `while also reducing the ACK rate as compared to`. Another clarification is needed about the fact that congestion controllers don't mark but respond to marks.\r\nSuggestion:\r\n```\r\nDoing so reduces the peer's response time to congestion events especially when peers are using DCTCP {{?RFC8257}} or other congestion controllers that respond to immediate CE markings which are much more\r\n frequent than classic ECN {{?RFC3168}}.\r\n ```\r\n And then talk about\r\n ```\r\n This will also help in reducing the ACK rate on the reverse path as compared to Section 13.2.1 of {{QUIC-TRANSPORT}}\r\n ```\r\n \r\n",
              "createdAt": "2021-09-13T00:13:10Z",
              "updatedAt": "2021-09-13T00:13:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODddxTs4s54JG",
          "commit": {
            "abbreviatedOid": "4b13883"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-14T00:43:04Z",
          "updatedAt": "2021-09-14T00:43:04Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "It doesn't actually reduce the response time compared to RFC9000, so I think the current text is more accurate?",
              "createdAt": "2021-09-14T00:43:04Z",
              "updatedAt": "2021-09-14T00:43:04Z"
            }
          ]
        }
      ]
    }
  ]
}